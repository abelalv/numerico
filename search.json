[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cálculo numérico",
    "section": "",
    "text": "Aqui nosotros presentaremos los apuntes de algunos métodos numéricos que se utilizan en la Ingenería. Los métodos numéricos son una herramienta muy útil para resolver problemas que no tienen solución analítica o que son muy complicados de resolver analíticamente."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "presentacion.html",
    "href": "presentacion.html",
    "title": "Primeros pasos con Phyton",
    "section": "",
    "text": "Antes de comenzar debemos instalar python en nuestro equipo\n\nVamos a la pagina oficial de anaconda y descargamos ultima vesrio de este software https://www.anaconda.com/products/individual\nInstalamos el software en nuestro equipo\nAbrimos una terminal y vamosa crear un entorno virtual para trabajar con python\n\n\nconda create -n python3 python=3.8\nAhora vamos a entrar al entornode trabajo\nconda activate python3\nNote que el nombre del entorno de trabajo aparece entre parentesis en la terminal. Ahora vamos a instalar jupyter notebook\nconda install -c conda-forge notebook\npara instalar la libreria numpy\nconda install -c anaconda numpy\nDesde la terminal podemos ejecutar jupyter notebook\njupyter notebook\nEsto nos abrira una ventana en el navegador donde podemos crear un nuevo notebook\n\n\n\njupyter"
  },
  {
    "objectID": "Python - Parte 1.html#entrada-y-salida",
    "href": "Python - Parte 1.html#entrada-y-salida",
    "title": "clases",
    "section": "2. Entrada y salida",
    "text": "2. Entrada y salida\nLos programas escritos en Python y los entornos de ejecución (como Google Colab) permiten al usuario interactuar de formas distintas. El usuario introduce información en forma de archivos, datos en la nube, o acciones de periféricos como el teclado y ratón, y los entornos de ejecución ejecutan el programa de Python. En consecuencia, le devuelven al usuario una respuesta en forma de texto, imagen o contenidos interactivos complejos. A continuación, conocera las funciones de entrada y salida de texto. Las más comunes y más útiles en los primeros pasos del aprendizaje del lenguaje son las funciones input y print.\nCuando se ejecuta input() la consola de Python espera que se le entregue texto, que puede escribir con su teclado o pegar del portapapeles, para luego hacer algo con este, como almacenarlo en una variable. Por otro lado, print() escribirá en consola texto que este almacenado previamente.\n\nnombre = input('Hola. ¿Cómo te llamas?\\n')\n\nHola. ¿Cómo te llamas?\nisa\n\n\n\nprint(\"¿Cómo se llama?\")\nnombre = input()\nprint(f\"Me alegro de conocerle, {nombre}\")\n\nNota: De forma predeterminada, la función input() siempre que lee algún dato, lo retorna como un string, incluso aunque sea un número válido y por ejemplo, si intentamos hacer operaciones, se producirá un error.\n\ncantidad = input(\"Dígame una cantidad en pesetas: \")\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nPara evitar lo mencionado anteriormente, se debe convertir el dato a número (float o int) según lo que se requiera en el programa. Veamos entonces cómo leer y convertir los números de la entrada en Python.\nEjemplo: Si se quiere que Python interprete la entrada como un número entero, se debe utilizar la función int() de la siguiente manera:\n\ncantidad = int(input(\"Dígame una cantidad en pesetas: \"))\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nEjemplo: Modifique el código anterior de tal manera que Python interprete la entrada como un float e imprima el valor con un redondeo de 3 dígitos."
  },
  {
    "objectID": "Python - Parte 1.html#tipos-de-dato-y-operadores",
    "href": "Python - Parte 1.html#tipos-de-dato-y-operadores",
    "title": "clases",
    "section": "3. Tipos de dato y operadores",
    "text": "3. Tipos de dato y operadores\n\nEl tipo de un dato es un atributo que determina qué operaciones se pueden realizar y qué valores puede tomar. Estos pueden ser números, listas, texto, entre otros. En Python, los tipos de dato no son definidos explícitamente, pero siempre están presentes en las variables que declaramos y es necesario tenerlos en cuenta. En particular, el tipo de dato define las operaciones válidas entre datos del mismo tipo. Estas operaciones están definidas con el uso de símbolos llamados operadores.\nPara conocer el tipo de dato de una variable, se usa la función type."
  },
  {
    "objectID": "Python - Parte 1.html#cadenas-de-texto",
    "href": "Python - Parte 1.html#cadenas-de-texto",
    "title": "clases",
    "section": "### 3.1. Cadenas de texto",
    "text": "### 3.1. Cadenas de texto\nUn tipo de dato muy importante es el de las cadenas de texto. Estas cadenas permiten almacenar en un mismo dato texto con cualquier cantidad de caracteres. Para definir una cadena de texto, se rodea el texto con comillas simples ' o comillas dobles \".\n\n'cadena con comilla simple'\n\n\n\"cadena con comillas dobles\"\n\nLas cadenas se pueden almacenar en variables, así:\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\n\n\nprint(c)\n\nAlgunos operadores de los usados para valores numéricos también sirven al operar con strings pero con utilidad distinta:\n\nConcatenación +.\nRepetición *.\nFormato %.\n\n\nConcatenación\n\n\nRepetición\n\n\nFormato\nEste operador permite reemplazar los marcadores de posición (%_) dentro de la string con la o las variables que se encuentren después del operador (%).\n\ntipo_calculo = \"raíz cuadrada de dos\"\nvalor = 2**0.5\nprint (\"el resultado de %s es %f\" % (tipo_calculo, valor))\n\nel resultado de raíz cuadrada de dos es 1.414214\n\n\nLas cadenas, como objetos que son, nos proporcionan métodos que nos facilitan su manipulación. Por ejemplo, siendo s una variable con un string:\n\ns.lower() : Retorna la cadena con todos los caracteres alfabéticos en minúscula.\ns.upper() : Retorna la cadena con todos los caracteres alfabéticos en mayúscula.\ns.replace(a, b) : Reemplaza las subcadenas iguales a la cadena a con el valor de la cadena b.\ns.strip() : Retorna la cadena con todos los espacios en blanco al principio y al final removidos.\ns.islower() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isupper() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isdigit() : Determina si la cadena está compuesta solo por dígitos del 0 al 9.\ns.isalpha() : Determina si la cadena está compuesta solo por caracteres alfabéticos.\n\nCada uno de los caracteres de una cadena (incluidos los espacios) tiene asignado un índice. Este indice nos permite seleccionar su carácter asociado haciendo referencia a él entre corchetes ([ ])\n\n\n\nimage.png\n\n\n\n\n3.2. Valores y operadores numéricos\n\nEn Python, los valores numéricos pueden ser de tres formas:\n\nNúmeros enteros. (int)\nNúmeros decimales. (float)\nNúmeros complejos. (complex)\n\n\na = 10            #int\nprint(a)\nprint(type(a))\n\n\na = -1089         #int - Se pueden escribir números negativos con el símbolo ‘-’\nprint(a)\nprint(type(a))\n\n\na = 1e100         #float - Esta sintaxis representa notación científica.\nprint(a)\nprint(type(a))\n\n1e+100\n<class 'float'>\n\n\n\na = 1 + 0.2j      #complex\nprint(a)\nprint(type(a))\n\n(1+0.2j)\n<class 'complex'>\n\n\nComo obtener la parte real e imaginaria de un numero complejo:\n\n(2.0+8.0j).real\n\n2.0\n\n\n\n(4.0+5.3j).imag\n\n5.3\n\n\nExisten varios operadores matemáticos para estos valores numéricos. Estos son:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n+\nsuma\n\n\n*\nMultiplicación\n\n\n/\nDivisión de numeros flotantes\n\n\n//\nDivisión de números enteros\n\n\n%\nMódulo\n\n\n**\nExponencial"
  },
  {
    "objectID": "Python - Parte 1.html#operados-logicos",
    "href": "Python - Parte 1.html#operados-logicos",
    "title": "clases",
    "section": "Operados logicos",
    "text": "Operados logicos\nOtro tipo de dato importante es el booleano, que representa un valor lógico de verdad. Puede tomar únicamente estos dos valores:\n\nVerdadero: True\nFalso: False\n\nEn Python, a diferencia de otros lenguajes de programación, las primitivas lógicas son escritas con la primera letra en mayúscula.\nAdemás de con el uso de las dos primitivas lógicas (True y False), se pueden obtener valores lógicos con la evaluación de expresiones con operadores relacionales. Los cuales se encuentran a continuación:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n==\nIgual\n\n\n!=\nDiferente\n\n\n<\nMenor que\n\n\n<=\nMenor igual que\n\n\n\\(>\\)\nMayor que\n\n\n\\(>=\\)\nMayor e igual que\n\n\n\n\nprint(-10  >   4.0)  # Mayor que.   \n\nFalse\n\n\n\nprint(-10  !=  4.0)  # Distinto que.\n\nTrue\n\n\n¿Puedo utilizar los operadores lógicos con string?\nPara evaluar más de una condición simultáneamente, se utilizan operadores lógicos. Estos son:\n\nAND lógico. and\nOR lógico. or\nNOT. negación. not\n\nEjemplo\nAdemás de estos operadores, se puede usar el operador is, que valida la identidad de un objeto. Para entender esto, tenemos que por su parte el operador == valida la igualdad de contenido de un objeto, mientras que el operador is valida si dos objetos, además de ser iguales en contenido, contienen la misma referencia en memoria, es decir, valida si son el mismo objeto. Si los valores son primitivas numéricas o lógicas el operador is retornará True.\n\n# Operador is\n\nprint('Operador is')\na = 1.0\nb = 1\n\nprint(a is b) # No tienen el mismo tipo de dato y por lo tanto son objetos distintos.\nprint(a == b) # Contienen el mismo valor al verificar su igualdad.\n\nOperador is\nFalse\nTrue"
  },
  {
    "objectID": "Python - Parte 2.html#condicionales-if-elif-y-else",
    "href": "Python - Parte 2.html#condicionales-if-elif-y-else",
    "title": "clases",
    "section": "1. Condicionales if, elif y else",
    "text": "1. Condicionales if, elif y else\n\nLas estructuras de control de flujo condicionales, permiten ejecutar bloques de código específicos según el valor de algunos datos. Se definen mediante el uso de tres palabras claves reservadas, del lenguaje: if (si), elif (sino, si) y else (sino).\nif test expression:\n    Body of if\nelif test expression:\n    Body of elif\nelse: \n    Body of else\nSi la condición que sigue a la palabra clave if se evalúa como verdadera , el bloque de código se ejecutará. Opcionalmente, puedes agregar una respuesta else la cual se ejecutará si la condición es false. Sin embargo, si se desea evaluar múltiples condiciones se usara la sentencia elif.\n\nEjemplo:\nTomemos un ejemplo de cómo encontrar un número que sea par y también mayor que 10\n\n'''En este programa, vamos a mirar si dado un numero \nes positivo, negativo o cero, con su respectivo mensaje '''\n\nnum = 3.4\n\nif num > 0:\n    print(\"Numero positivo\")\nelif num == 0:\n    print(\"Cero\")\nelse:\n    print(\"Numero negativo\")\n\nNumero positivo\n\n\n\n\nEjercicio 1\nEscribir un programa que almacene la cadena de caracteres contraseña en una variable, pregunte al usuario por la contraseña e imprima por pantalla si la contraseña introducida por el usuario coincide con la guardada en la variable sin tener en cuenta mayúsculas y minúsculas.\n\nLa clave debe estar en minuscula"
  },
  {
    "objectID": "Python - Parte 2.html#bucle-for",
    "href": "Python - Parte 2.html#bucle-for",
    "title": "clases",
    "section": "## 2. Bucle for",
    "text": "## 2. Bucle for\nLa estructura repetitiva For es aquella en la que el número de iteraciones se conoce por anticipado, y por ello no se precisa poner ninguna condición de salida para detener el bucle. En su lugar un contador cuenta el número de iteraciones fijas y se termina cuando llega al valor final previamente definido.\nSintaxis:\nfor <elem> in <iterable>:\n    <Código>\nAquí, elem es la variable que toma el valor del elemento dentro del iterador en cada paso del bucle. Este finaliza su ejecución cuando se recorren todos los elementos. Es frecuente usar el bucle for para iterar sobre los elementos de listas, tuplas o diccionarios.\n\nFunción range\nPara recorrer un conjunto de código un número específico de veces, podemos usar la función range(n), la cual devuelve una secuencia de números, comenzando desde 0 de forma predeterminada, se incrementa en 1 (de forma predeterminada) y termina cuando llega a n - 1.\n\nfor x in range(6):\n  print(x)\n\n0\n1\n2\n3\n4\n5\n\n\nLa función range(n) por defecto toma 0 como valor inicial, sin embargo, es posible especificar el valor inicial agregando un parámetro: range(2, 6) , lo que significa que toma valores del 2 al 6 (pero sin incluir el 6)\n\nfor x in range(2, 6):\n  print(x)\n\n2\n3\n4\n5\n\n\nLa función range(n) por defecto incrementa la secuencia en 1, sin embargo, agregando un tercer parámetro se puede especificar el valor del incremento: range(2, 30, 3 )\n\nfor x in range(1, 15, 3):\n  print(x)\n\n1\n4\n7\n10\n13\n\n\nCon for también puedo recorrer una cadena de caracteres:\n\ntexto=\"Isabella\"\nfor i in texto:\n    print(i)\n    #print(i,end=\"\")\n\nI\ns\na\nb\ne\nl\nl\na"
  },
  {
    "objectID": "Python - Parte 2.html#bucle-while",
    "href": "Python - Parte 2.html#bucle-while",
    "title": "clases",
    "section": "3. Bucle While",
    "text": "3. Bucle While\n\nEl ciclo while en Python se usa para iterar sobre un bloque de código siempre que la expresión de prueba (condición) sea verdadera. Generalmente usamos este ciclo cuando no sabemos la cantidad de veces que necesitamos iterar una sentencia.\nSintaxis:\nwhile test_expression:\n    Body of while\nEn el bucle while, primero se comprueba la expresión de prueba. El cuerpo del ciclo se ingresa solo si test_expression se evalúa como True. Después de una iteración, la expresión de prueba se verifica nuevamente. Este proceso continúa hasta que test_expression se evalue como False.\n\nx = 5\nwhile x > 0:\n    x -=1\n    print(x)\n\n4\n3\n2\n1\n0\n\n\n\nEjercicio 2\nUna empresa de ropa de la ciudad de Cali, va a lanzar una promoción sobre sus productos de la siguiente manera:\nSi el cliente compra menos de 5 productos, y si estos productos tienen un valor total menor a 100.000 COP, entonces se realizará un descuento del 10%. Si la compra es por un valor mayor o igual a 100.000 COP, el descuento es del 15% Si el cliente compra entre 5 a 10 productos, y el valor total de estos es mayor a 500.000 COP entonces se realizará un descuento del 20%, de lo contrario el descuento es del 18%. Si el cliente compra más de 10 productos y el valor total de la compra es menor a 1.000.000, el descuento será del 30%, en caso contrario el descuento es del 40%.\nEscriba un programa en Python que permita calcular el valor total a pagar del cliente teniendo en cuenta las condiciones dadas anteriormente,.\n\n\nEjercicio 3\nEscribir un programa en el que se pregunte al usuario por una frase y una letra, y muestre por pantalla el número de veces que aparece la letra en la frase.\n\n\nEjercicio 4\nRealice un programa que permita resolver la siguiente sumatoria:\n$ _{i=1}{n}(n3+n^2+3) $"
  },
  {
    "objectID": "Python - Parte 2.html#funciones",
    "href": "Python - Parte 2.html#funciones",
    "title": "clases",
    "section": "## 3. Funciones",
    "text": "## 3. Funciones\nLas funciones son bloques de código que se pueden reutilizar simplemente llamando a la función.\ndef identificador(param1, param2,..):\n    inst1\n    inst2\n    .\n    .\n    return valor\nPara definir una función en Python se utiliza la palabra reservada def. A continuación viene el nombre o identificador de la función que es el que se utiliza para invocarla dentro del código. Después del nombre hay que incluir los paréntesis y una lista opcional de parámetros. Por último, la definición de la función termina con dos puntos.\nTras los dos puntos se incluye el cuerpo de la función, en donde se encuentra el conjunto de instrucciones que se encapsulan en dicha función y finalmente, de manera opcional, se añade la instrucción con la palabra reservada return para devolver un resultado.\n\ndef new_function():\n  print(\"Hola, estoy en la función\")\n\nnew_function()\n\nHola, estoy en la función\n\n\nLas funciones permiten la reutilización de código es decir, que se evita escribir nuevamente secciones de código. Esto hace que el código sea más legible, facilita la depuración y limita los errores de escritura.\n\ndef func_name(nombre):\n  print(\" Hola,\", nombre)\n\n# Importante tener en cuenta la cantidad de argumentos que la función recibira\n\nfunc_name(\"Camilo\")\nfunc_name(\"Juan\")\nfunc_name(\"Maria\")\n\n Hola, Camilo\n Hola, Juan\n Hola, Maria\n\n\n\nEjercicio 5\nRealice un programa que pida n cantidad de numeros y por medio de un mensaje, muestre si el numero es par o no.\n\n\nReferencias:\nhttps://www.w3schools.com/PYTHON/"
  },
  {
    "objectID": "Python - Parte 3.html#listas",
    "href": "Python - Parte 3.html#listas",
    "title": "clases",
    "section": "## 4.1 Listas",
    "text": "## 4.1 Listas\nLas listas son el tipo de colección más común. Son estructuras de datos ordenadas con longitud variable. Esto quiere decir, que tras su declaración se pueden agregar o eliminar elementos específicos de su contenido. Además, estos elementos ocupan una posición definida secuencialmente, siendo el primer elemento el que ocupa la posición 0.\nExisten dos formas de declarar listas en Python: * Con llaves cuadradas.    Ejemplo: l = [] * Con la función list.      Ejemplo: l = list()\nEn el momento de su definición, se pueden definir valores por defecto, separados por coma.\n\nl = [1, 'Hola', 4.5]\nprint(l)\ntype(l)\n\n[1, 'Hola', 4.5]\n\n\nlist\n\n\nLas listas en Python son:\n\nHeterogéneas: Pueden estar conformadas por elementos de distintos tipo, incluyendo otras listas.\nMutables: Sus elementos pueden modificarse.\n\n\nl = [1, 2.5, [4, 5, 6, 7], \"Fin\"]\nprint(l)\ntype(l)\n\n[1, 2.5, [4, 5, 6, 7], 'Fin']\n\n\nlist\n\n\nLos elementos de una lista pueden accederse mediante su índice, siendo 0 el índice del primer elemento.\n\nprint(l[1])\n\nHola\n\n\nSe pueden realizar operaciones entre listas mediante algunos operadores. Es importante tener en cuenta los tipos de dato, pues símbolos como estos funcionan de manera distinta en relación al tipo de dato que manejan. Estos operadores básicos son:\n\nConcatenación +: Al aplicar este operador, se agregan los elementos de la segunda lista al final de la primera.\nRepetición *: Al aplicar este operador, se repiten los elementos la cantidad de veces expresada en el segundo operando.\n\n\nl_a = [1, 2, 3]\nl_b = ['a', 'b', 'c']\n\n\n# Concatenar\n\n\n# Repetición\n\n\nAlgunos comandos de la lista de metodos:\n\n\n\n\n\n\n\nMétodos\nDescripción\n\n\n\n\nappend(elemento)\nagregar elemento al final de la lista\n\n\nextend(lis2)\nExtiende la lista con los elementos de la lista 2\n\n\nindex(element)\nDevuelve el índice más bajo de la lista que contiene el elemento.\n\n\ninsert(index,element)\nInserta un elemento para el indice index\n\n\npop(i)\nElimina y retorna el elemento en la posición i\n\n\nreverse(element)\nInvierte la lista de lugar\n\n\nremove(element)\nElimina la primera aparición del elemento de la lista\n\n\nsort()\nClasifica la lista en lugar\n\n\ncopy()\nRetorna la copia de la lista\n\n\ncount(element)\nRetorna el némero de elementos igual al elemento de la lista\n\n\n\n\n\nUtilizar los metodos:\n\n\nInterando listas\n\nlista = [\"manzana\", \"banana\", \"cereza\"]\nfor x in lista:\n  print(x)\n\nmanzana\nbanana\ncereza"
  },
  {
    "objectID": "Python - Parte 3.html#tuplas",
    "href": "Python - Parte 3.html#tuplas",
    "title": "clases",
    "section": "4.2 Tuplas",
    "text": "4.2 Tuplas\n\nSon similares a las listas, pero lo que las diferencia es que estas son inmutables, esto quiere decir que no puede modificarse de ninguna forma después de que sean creadas. Los elementos de tupla están ordenados y permiten valores duplicados. Las tuplas se pueden definir de dos formas:\n\ntupla = (1,2,3,4)\n\n# También de esta forma\n\ntupla = tuple((1, 2, 3, 4))\n\nPara acceder a un valor dada una posición se realiza igual que con las listas, se escribe el nombre de la tupla seguido de apertura de corchetes, posición que buscamos y cierre de corchetes.\n\ntupla = tuple((1,2,3, 'r'))\nprint(tupla[1])\n\n2\n\n\nSe pueden recorrer los elementos de una tupla con for:\n\nfor dato in tupla:\n    print(dato, end=\" \")\n\n1 2 3 r \n\n\n\nFunciones de las tuplas:\nLongitud de una tupla\n\ntup = (1,2,13,-50)\nlen(tup)\n\n4\n\n\nMáximo de una tupla\n\ntup = (1,2,13,-50)\nmax(tup)\n\n13\n\n\nMinimo de una tupla\n\ntup = (1,2,13,-50)\nmin(tup)\n\n-50"
  },
  {
    "objectID": "Python - Parte 3.html#set",
    "href": "Python - Parte 3.html#set",
    "title": "clases",
    "section": "## 4.3 Set",
    "text": "## 4.3 Set\nLos conjuntos se utilizan para almacenar varios elementos en una sola variable. Un conjunto es una colección desordenada , inmutable* y no indexada.\n\nNota: Los elementos establecidos no se pueden modificar, pero puede eliminar elementos y agregar elementos nuevos.\n\n\nvocales = {'a', 'e', 'i', 'o', 'u', 'a', 'a', 'o', 'e'}\nprint(vocales)\n\nDado que los conjuntos son colecciones desordenadas, en ellos no se guarda la posición en la que son insertados los elementos como ocurre en los tipos lista o tuplas. Es por ello que no se puede acceder a los elementos a través de un índice.\nSin embargo, haciendo uso de un bucle for se puede acceder y/o recorrer todos los elementos del conjunto.\n\nprint(vocales{2})\n\nSyntaxError: invalid syntax (Temp/ipykernel_1032/3960885320.py, line 3)\n\n\n\nfor e in vocales:\n    print(e)\n\nu\na\ne\ni\no\n\n\nMetodos para utilizar en conjuntos.\n\nAgregar elementos\nUna vez que se crea un conjunto, no puede cambiar sus elementos, pero puede agregar nuevos elementos. Para agregar un elemento a un conjunto, utilice el método add().\n\nconjunto = {\"manzana\", \"cereza\", \"fresa\"}\n\nconjunto.add(\"mango\")\n\nprint(conjunto)\n\n{'manzana', 'cereza', 'mango', 'fresa'}\n\n\n\n\nAgregar conjuntos\nPara agregar elementos de otro conjunto al conjunto actual, utilice el método update(), se puede tomar como argumento una lista, tupla, string, conjunto o cualquier objeto de tipo iterable.\n\nconjunto = {\"manzana\", \"cereza\", \"fresa\"}\nlista = [\"kiwi\", \"naranja\"]\n\nconjunto.update(lista)\n\nprint(conjunto)\n\n{'fresa', 'manzana', 'naranja', 'cereza', 'kiwi'}\n\n\n\nAlgunos comandos de la lista de metodos:\n\n\n\n\n\n\n\nMétodos\nDescripción\n\n\n\n\nadd()\nAñade un elemento\n\n\nclear()\nRemueve todos los elementos\n\n\ncopy()\nEntrega una copia del set\n\n\ndifference()\nEntrega un set conteniendo los miembros diferentes entre dos o más sets\n\n\ndifference_update()\nRemueve los elementos en este set que también se incluyen en otro set específico\n\n\ndiscard()\nElimina, si existe, el elemento del conjunto.\n\n\nintersection()\nEntrega un set, que es la intersección de otros dos sets\n\n\nintersec_update()\nRemueve los elementos en este set que no se encuentran presentes en otro set específico.\n\n\nisdisjoint()\nEntrega si dos sets tienen una intersección o no\n\n\nissubset()\nEntrega si otro set contiene este set o no\n\n\nissuperset()\nEntrega si este set contiene otro set o no\n\n\npop()\nObtiene y elimina un elemento de forma aleatoria del conjunto\n\n\nremove()\nElimina el elemento del conjunto. Si no existe lanza un error.\n\n\nsymmetric_difference()\nEntrega un set con la diferencia simétrica de dos sets\n\n\nunion()\nEntrega un set que contiene la unión de dos sets\n\n\nupdate()\nActualiza el set con la unión de éste y otros sets\n\n\n\n\n\n\nUnir dos conjuntos\nHay varias formas de unir dos o más conjuntos en Python.\nPuede usar el método union() que devuelve un nuevo conjunto que contiene todos los elementos de ambos conjuntos, o el método update() que inserta todos los elementos de un conjunto en otro:\n\nset1 = {\"a\", \"b\" , \"c\"}\nset2 = {1, 2, 3}\n\nset3 = set1.union(set2)\nprint(set3)\n\n{1, 2, 'a', 3, 'b', 'c'}\n\n\nEl método update() inserta los elementos en set2 en set1:\n\nset1 = {\"a\", \"b\" , \"c\"}\nset2 = {1, 2, 3}\n\nset1.update(set2)\nprint(set1)"
  },
  {
    "objectID": "Python - Parte 3.html#diccionarios",
    "href": "Python - Parte 3.html#diccionarios",
    "title": "clases",
    "section": "4.4 Diccionarios",
    "text": "4.4 Diccionarios\n\nUn diccionario de Python es una estructura de datos para almacenar grupos de objetos. Consiste en un mapeo de pares clave-valor, donde cada clave está asociada a un valor. Puede contener tipos de datos iguales o diferentes, no está ordenado y es mutable.\n\nclases = {\n    \"Analisis\": 10,\n    \"Algebra\": 25,\n    \"Fundamentos\": 30,\n    \"Discretas\": 14,\n    \"Multivariable\": 27,\n    \"Etica\": 35\n}\n\nprint(clases,\"\\n\")\nprint(clases.keys(),\"\\n\")\nprint(clases.values(),\"\\n\")\nprint(clases.items(),\"\\n\")\n\n{'Analisis': 10, 'Algebra': 25, 'Fundamentos': 30, 'Discretas': 14, 'Multivariable': 27, 'Etica': 35} \n\ndict_keys(['Analisis', 'Algebra', 'Fundamentos', 'Discretas', 'Multivariable', 'Etica']) \n\ndict_values([10, 25, 30, 14, 27, 35]) \n\ndict_items([('Analisis', 10), ('Algebra', 25), ('Fundamentos', 30), ('Discretas', 14), ('Multivariable', 27), ('Etica', 35)]) \n\n\n\n\nMetodos para diccionarios\n\n\nAgregar un elemento\nPara agregar un nuevo par de valores clave o actualizar uno existente en un diccionario de Python, puede usar el operador [ ] e ingresar la clave para actualizar o agregar y seguirlo con un = y el valor.\n\nupdate ( ): Función dedicada para agregar o actualizar un par de valores. Toma otro diccionario como argumento, lista o tupla que representa los pares de valores clave.\nsetdefault ( ): Sirve para agregar un nuevo elemento a nuestro diccionario.\npop ( ): Este método remueve específicamente una clave de diccionario y devuelve su valor correspondiente. Si no lo encuentra, devuelve error.\npopitem ( ): Este método remueve y devuelve algún par (clave, valor) del diccionario como una 2 tuplas. Lanza una excepción KeyError si el diccionario esta vació.\nget ( ): Recibe como parámetro una clave, devuelve el valor de la clave. Si no lo encuentra, devuelve un objeto none.\ncopy ( ): Retorna una copia del diccionario original.\nclear ( ): Elimina todos los ítems del diccionario dejándolo vacío.\nzip ( ): Recibe como parámetro dos elementos iterables, ya sea una cadena, una lista o una tupla. Ambos parámetros deben tener el mismo número de elementos. Se devolverá un diccionario relacionando el elemento i-esimo de cada uno de los iterables.\n\n\nclases = {\n    \"Analisis\": 10,\n    \"Algebra\": 25,\n    \"Fundamentos\": 30,\n    \"Discretas\": 14,\n    \"Multivariable\": 27,\n    \"Etica\": 35\n}\n\n# Agregar un elemento\n\n# Eliminar un elemento\n\n#Zip\n\ndic = dict(zip('abcd',[1,2,3,4]))\nprint(dic)\n\n{'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\n\n\n\nIterando en diccionarios\n\n# Imprime los key del diccionario\nfor key in clases:\n    print(key)\n\nAnalisis\nAlgebra\nFundamentos\nDiscretas\nMultivariable\nEtica\n\n\n\nprint(\"Metodo 1 \\n\")\n# Imprime los value del diccionario\nfor key in clases:\n    print(clases[key])\n\nprint(\"\")\nprint(\"Metodo 2 \\n\")\n# Otro metodo\nfor value in clases.values():\n    print(value)\n\nMetodo 1 \n\n10\n25\n30\n14\n27\n35\n\nMetodo 2 \n\n10\n25\n30\n14\n27\n35\n\n\n\n# Imprime los key y value del diccionario\nfor x, y in clases.items():\n    print(x, y)\n\nAnalisis 10\nAlgebra 25\nFundamentos 30\nDiscretas 14\nMultivariable 27\nEtica 35\n\n\n\n# Diccionario con lista\n\ngrocery_items = {\"eggs\": [3.99, 4.99, 5.50],\n                 \"banana\": 1.49,\n                 \"cheese\": 4.5,\n                 \"eggplant\": 2.5,\n                \"bread\": 3.99}\n\ns = grocery_items[\"eggs\"]\nprint(s)\ns = grocery_items[\"eggs\"][0]\nprint(s)\n\n[3.99, 4.99, 5.5]\n3.99"
  },
  {
    "objectID": "Python - Parte 3.html#excepciones",
    "href": "Python - Parte 3.html#excepciones",
    "title": "clases",
    "section": "5. Excepciones",
    "text": "5. Excepciones\nLas excepciones en Python son una herramienta muy potente que la gran mayoría de lenguajes de programación modernos tienen. Se trata de una forma de controlar el comportamiento de un programa cuando se produce un error.\nImaginemos ahora que por cualquier motivo se quieren dividir nos variables (a/b), y que por ejemplo b tiene el valor 0. Si intentamos hacer la división entre cero, este programa dará un error y su ejecución terminará de manera abrupta.\n\na = 4; b = 0\nprint(a/b)\n\nZeroDivisionError: division by zero\n\n\nUna primera aproximación al control de exepciones podria ser la siguiente:\n\na = 5\nb = 0\n# A través de esta comprobación prevenimos que se divida entre cero.\nif b!=0:\n    print(a/b)\nelse:\n    print(\"No se puede dividir!\")\n\nNo se puede dividir!\n\n\nSin embargo, en Python puedes usar los bloques try y except para manejar estos errores como excepciones.\ntry:\n    # Codigo a ejecutar\n    # Pero podria haber errores en este bloque\n    \nexcept <tipo de error>:\n    # Haz esto para manejar la excepcion\n    # El bloque except se ejecutara si el bloque try lanza un error\n    \nelse:\n    # Esto se ejecutara si el bloque try se ejecuta sin errores\n   \nfinally:\n    # Este bloque se ejecutara siempre\n\nEl bloque try es el bloque con las sentencias que quieres ejecutar. Sin embargo, podrían llegar a haber errores de ejecución y el bloque se dejará de ejecutarse.\nEl bloque except se ejecutará cuando el bloque try falle debido a un error. Este bloque contiene sentencias que generalmente nos dan un contexto de lo que salió mal en el bloque try. Siempre se debe mencionar el tipo de error que se espera, como una excepción dentro del bloque except en <tipo de error> ya que de esta manera se identifica el tipo de error que podria ocurrir.\nEl bloque else se ejecutará solo si el bloque try se ejecuta sin errores.\nEl bloque finally siempre es ejecutado sin importar que pase en los otros bloques, esto puede ser útil cuando quieras liberar recursos después de la ejecución de un bloque de código.\n\n\nNota: Los bloques else y finally son opcionales.\n\nEl ejemplo anterior, utilizando estos bloques quedaria de la siguiente manera:\n\na = 5; b = 0\ntry:\n    c = a/b\nexcept ZeroDivisionError:\n    print(\"No se ha podido realizar la división\")\n\nNo se ha podido realizar la división"
  },
  {
    "objectID": "Python - Parte 3.html#lectura-de-archivos",
    "href": "Python - Parte 3.html#lectura-de-archivos",
    "title": "clases",
    "section": "6. Lectura de archivos",
    "text": "6. Lectura de archivos\nMuchas veces necesitamos que nuestros cálculos sean escritos en un archivo externo y no solamente escritos en la consola. Para ello usamos Python file.\n\n\n\n\n\n\n\nArgumento\nDescripción\n\n\n\n\nr\nTexto, leer solamente\n\n\nw\nTexto, escribir ( si existe un archivo con el mismo nombre este lo sobreescribe)\n\n\na\nTexto, adjuntar el texto al archivo ya existente\n\n\nr+\nTexto, leer y escribir\n\n\nrb\nBinario, leer solamente\n\n\nwb\nBinario, escribir ( si existe un archivo con el mismo nombre este lo sobreescribe)\n\n\nab\nBinario, adjuntar el texto al archivo ya existente\n\n\nrb+\nBinario leer y escribir\n\n\n\n\nReferencias:\nhttps://www.freecodecamp.org/espanol/news/sentencias-try-y-except-de-python-como-menejar-excepciones-en-python/ https://www.w3schools.com/python/python_try_except.asp"
  },
  {
    "objectID": "Python_Parte_1.html#entrada-y-salida",
    "href": "Python_Parte_1.html#entrada-y-salida",
    "title": "clases",
    "section": "2. Entrada y salida",
    "text": "2. Entrada y salida\nLos programas escritos en Python y los entornos de ejecución (como Google Colab) permiten al usuario interactuar de formas distintas. El usuario introduce información en forma de archivos, datos en la nube, o acciones de periféricos como el teclado y ratón, y los entornos de ejecución ejecutan el programa de Python. En consecuencia, le devuelven al usuario una respuesta en forma de texto, imagen o contenidos interactivos complejos. A continuación, conocera las funciones de entrada y salida de texto. Las más comunes y más útiles en los primeros pasos del aprendizaje del lenguaje son las funciones input y print.\nCuando se ejecuta input() la consola de Python espera que se le entregue texto, que puede escribir con su teclado o pegar del portapapeles, para luego hacer algo con este, como almacenarlo en una variable. Por otro lado, print() escribirá en consola texto que este almacenado previamente.\n\nnombre = input('Hola. ¿Cómo te llamas?\\n')\n\nHola. ¿Cómo te llamas?\nisa\n\n\n\nprint(\"¿Cómo se llama?\")\nnombre = input()\nprint(f\"Me alegro de conocerle, {nombre}\")\n\nNota: De forma predeterminada, la función input() siempre que lee algún dato, lo retorna como un string, incluso aunque sea un número válido y por ejemplo, si intentamos hacer operaciones, se producirá un error.\n\ncantidad = input(\"Dígame una cantidad en pesetas: \")\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nPara evitar lo mencionado anteriormente, se debe convertir el dato a número (float o int) según lo que se requiera en el programa. Veamos entonces cómo leer y convertir los números de la entrada en Python.\nEjemplo: Si se quiere que Python interprete la entrada como un número entero, se debe utilizar la función int() de la siguiente manera:\n\ncantidad = int(input(\"Dígame una cantidad en pesetas: \"))\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nEjemplo: Modifique el código anterior de tal manera que Python interprete la entrada como un float e imprima el valor con un redondeo de 3 dígitos."
  },
  {
    "objectID": "Python_Parte_1.html#tipos-de-dato-y-operadores",
    "href": "Python_Parte_1.html#tipos-de-dato-y-operadores",
    "title": "clases",
    "section": "3. Tipos de dato y operadores",
    "text": "3. Tipos de dato y operadores\n\nEl tipo de un dato es un atributo que determina qué operaciones se pueden realizar y qué valores puede tomar. Estos pueden ser números, listas, texto, entre otros. En Python, los tipos de dato no son definidos explícitamente, pero siempre están presentes en las variables que declaramos y es necesario tenerlos en cuenta. En particular, el tipo de dato define las operaciones válidas entre datos del mismo tipo. Estas operaciones están definidas con el uso de símbolos llamados operadores.\nPara conocer el tipo de dato de una variable, se usa la función type."
  },
  {
    "objectID": "Python_Parte_1.html#cadenas-de-texto",
    "href": "Python_Parte_1.html#cadenas-de-texto",
    "title": "clases",
    "section": "### 3.1. Cadenas de texto",
    "text": "### 3.1. Cadenas de texto\nUn tipo de dato muy importante es el de las cadenas de texto. Estas cadenas permiten almacenar en un mismo dato texto con cualquier cantidad de caracteres. Para definir una cadena de texto, se rodea el texto con comillas simples ' o comillas dobles \".\n\n'cadena con comilla simple'\n\n\n\"cadena con comillas dobles\"\n\nLas cadenas se pueden almacenar en variables, así:\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\n\n\nprint(c)\n\nAlgunos operadores de los usados para valores numéricos también sirven al operar con strings pero con utilidad distinta:\n\nConcatenación +.\nRepetición *.\nFormato %.\n\n\nConcatenación\n\n\nRepetición\n\n\nFormato\nEste operador permite reemplazar los marcadores de posición (%_) dentro de la string con la o las variables que se encuentren después del operador (%).\n\ntipo_calculo = \"raíz cuadrada de dos\"\nvalor = 2**0.5\nprint (\"el resultado de %s es %f\" % (tipo_calculo, valor))\n\nel resultado de raíz cuadrada de dos es 1.414214\n\n\nLas cadenas, como objetos que son, nos proporcionan métodos que nos facilitan su manipulación. Por ejemplo, siendo s una variable con un string:\n\ns.lower() : Retorna la cadena con todos los caracteres alfabéticos en minúscula.\ns.upper() : Retorna la cadena con todos los caracteres alfabéticos en mayúscula.\ns.replace(a, b) : Reemplaza las subcadenas iguales a la cadena a con el valor de la cadena b.\ns.strip() : Retorna la cadena con todos los espacios en blanco al principio y al final removidos.\ns.islower() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isupper() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isdigit() : Determina si la cadena está compuesta solo por dígitos del 0 al 9.\ns.isalpha() : Determina si la cadena está compuesta solo por caracteres alfabéticos.\n\nCada uno de los caracteres de una cadena (incluidos los espacios) tiene asignado un índice. Este indice nos permite seleccionar su carácter asociado haciendo referencia a él entre corchetes ([ ])\n\n\n\nimage.png\n\n\n\n\n3.2. Valores y operadores numéricos\n\nEn Python, los valores numéricos pueden ser de tres formas:\n\nNúmeros enteros. (int)\nNúmeros decimales. (float)\nNúmeros complejos. (complex)\n\n\na = 10            #int\nprint(a)\nprint(type(a))\n\n\na = -1089         #int - Se pueden escribir números negativos con el símbolo ‘-’\nprint(a)\nprint(type(a))\n\n\na = 1e100         #float - Esta sintaxis representa notación científica.\nprint(a)\nprint(type(a))\n\n1e+100\n<class 'float'>\n\n\n\na = 1 + 0.2j      #complex\nprint(a)\nprint(type(a))\n\n(1+0.2j)\n<class 'complex'>\n\n\nComo obtener la parte real e imaginaria de un numero complejo:\n\n(2.0+8.0j).real\n\n2.0\n\n\n\n(4.0+5.3j).imag\n\n5.3\n\n\nExisten varios operadores matemáticos para estos valores numéricos. Estos son:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n+\nsuma\n\n\n*\nMultiplicación\n\n\n/\nDivisión de numeros flotantes\n\n\n//\nDivisión de números enteros\n\n\n%\nMódulo\n\n\n**\nExponencial"
  },
  {
    "objectID": "Python_Parte_1.html#operados-logicos",
    "href": "Python_Parte_1.html#operados-logicos",
    "title": "clases",
    "section": "Operados logicos",
    "text": "Operados logicos\nOtro tipo de dato importante es el booleano, que representa un valor lógico de verdad. Puede tomar únicamente estos dos valores:\n\nVerdadero: True\nFalso: False\n\nEn Python, a diferencia de otros lenguajes de programación, las primitivas lógicas son escritas con la primera letra en mayúscula.\nAdemás de con el uso de las dos primitivas lógicas (True y False), se pueden obtener valores lógicos con la evaluación de expresiones con operadores relacionales. Los cuales se encuentran a continuación:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n==\nIgual\n\n\n!=\nDiferente\n\n\n<\nMenor que\n\n\n<=\nMenor igual que\n\n\n\\(>\\)\nMayor que\n\n\n\\(>=\\)\nMayor e igual que\n\n\n\n\nprint(-10  >   4.0)  # Mayor que.   \n\nFalse\n\n\n\nprint(-10  !=  4.0)  # Distinto que.\n\nTrue\n\n\n¿Puedo utilizar los operadores lógicos con string?\nPara evaluar más de una condición simultáneamente, se utilizan operadores lógicos. Estos son:\n\nAND lógico. and\nOR lógico. or\nNOT. negación. not\n\nEjemplo\nAdemás de estos operadores, se puede usar el operador is, que valida la identidad de un objeto. Para entender esto, tenemos que por su parte el operador == valida la igualdad de contenido de un objeto, mientras que el operador is valida si dos objetos, además de ser iguales en contenido, contienen la misma referencia en memoria, es decir, valida si son el mismo objeto. Si los valores son primitivas numéricas o lógicas el operador is retornará True.\n\n# Operador is\n\nprint('Operador is')\na = 1.0\nb = 1\n\nprint(a is b) # No tienen el mismo tipo de dato y por lo tanto son objetos distintos.\nprint(a == b) # Contienen el mismo valor al verificar su igualdad.\n\nOperador is\nFalse\nTrue"
  },
  {
    "objectID": "Python_Parte_2.html#condicionales-if-elif-y-else",
    "href": "Python_Parte_2.html#condicionales-if-elif-y-else",
    "title": "clases",
    "section": "1. Condicionales if, elif y else",
    "text": "1. Condicionales if, elif y else\n\nLas estructuras de control de flujo condicionales, permiten ejecutar bloques de código específicos según el valor de algunos datos. Se definen mediante el uso de tres palabras claves reservadas, del lenguaje: if (si), elif (sino, si) y else (sino).\nif test expression:\n    Body of if\nelif test expression:\n    Body of elif\nelse: \n    Body of else\nSi la condición que sigue a la palabra clave if se evalúa como verdadera , el bloque de código se ejecutará. Opcionalmente, puedes agregar una respuesta else la cual se ejecutará si la condición es false. Sin embargo, si se desea evaluar múltiples condiciones se usara la sentencia elif.\n\nEjemplo:\nTomemos un ejemplo de cómo encontrar un número que sea par y también mayor que 10\n\n'''En este programa, vamos a mirar si dado un numero \nes positivo, negativo o cero, con su respectivo mensaje '''\n\nnum = 3.4\n\nif num > 0:\n    print(\"Numero positivo\")\nelif num == 0:\n    print(\"Cero\")\nelse:\n    print(\"Numero negativo\")\n\nNumero positivo\n\n\n\n\nEjercicio 1\nEscribir un programa que almacene la cadena de caracteres contraseña en una variable, pregunte al usuario por la contraseña e imprima por pantalla si la contraseña introducida por el usuario coincide con la guardada en la variable sin tener en cuenta mayúsculas y minúsculas.\n\nLa clave debe estar en minuscula"
  },
  {
    "objectID": "Python_Parte_2.html#bucle-for",
    "href": "Python_Parte_2.html#bucle-for",
    "title": "clases",
    "section": "## 2. Bucle for",
    "text": "## 2. Bucle for\nLa estructura repetitiva For es aquella en la que el número de iteraciones se conoce por anticipado, y por ello no se precisa poner ninguna condición de salida para detener el bucle. En su lugar un contador cuenta el número de iteraciones fijas y se termina cuando llega al valor final previamente definido.\nSintaxis:\nfor <elem> in <iterable>:\n    <Código>\nAquí, elem es la variable que toma el valor del elemento dentro del iterador en cada paso del bucle. Este finaliza su ejecución cuando se recorren todos los elementos. Es frecuente usar el bucle for para iterar sobre los elementos de listas, tuplas o diccionarios.\n\nFunción range\nPara recorrer un conjunto de código un número específico de veces, podemos usar la función range(n), la cual devuelve una secuencia de números, comenzando desde 0 de forma predeterminada, se incrementa en 1 (de forma predeterminada) y termina cuando llega a n - 1.\n\nfor x in range(6):\n  print(x)\n\n0\n1\n2\n3\n4\n5\n\n\nLa función range(n) por defecto toma 0 como valor inicial, sin embargo, es posible especificar el valor inicial agregando un parámetro: range(2, 6) , lo que significa que toma valores del 2 al 6 (pero sin incluir el 6)\n\nfor x in range(2, 6):\n  print(x)\n\n2\n3\n4\n5\n\n\nLa función range(n) por defecto incrementa la secuencia en 1, sin embargo, agregando un tercer parámetro se puede especificar el valor del incremento: range(2, 30, 3 )\n\nfor x in range(1, 15, 3):\n  print(x)\n\n1\n4\n7\n10\n13\n\n\nCon for también puedo recorrer una cadena de caracteres:\n\ntexto=\"Isabella\"\nfor i in texto:\n    print(i)\n    #print(i,end=\"\")\n\nI\ns\na\nb\ne\nl\nl\na"
  },
  {
    "objectID": "Python_Parte_2.html#bucle-while",
    "href": "Python_Parte_2.html#bucle-while",
    "title": "clases",
    "section": "3. Bucle While",
    "text": "3. Bucle While\n\nEl ciclo while en Python se usa para iterar sobre un bloque de código siempre que la expresión de prueba (condición) sea verdadera. Generalmente usamos este ciclo cuando no sabemos la cantidad de veces que necesitamos iterar una sentencia.\nSintaxis:\nwhile test_expression:\n    Body of while\nEn el bucle while, primero se comprueba la expresión de prueba. El cuerpo del ciclo se ingresa solo si test_expression se evalúa como True. Después de una iteración, la expresión de prueba se verifica nuevamente. Este proceso continúa hasta que test_expression se evalue como False.\n\nx = 5\nwhile x > 0:\n    x -=1\n    print(x)\n\n4\n3\n2\n1\n0\n\n\n\nEjercicio 2\nUna empresa de ropa de la ciudad de Cali, va a lanzar una promoción sobre sus productos de la siguiente manera:\nSi el cliente compra menos de 5 productos, y si estos productos tienen un valor total menor a 100.000 COP, entonces se realizará un descuento del 10%. Si la compra es por un valor mayor o igual a 100.000 COP, el descuento es del 15% Si el cliente compra entre 5 a 10 productos, y el valor total de estos es mayor a 500.000 COP entonces se realizará un descuento del 20%, de lo contrario el descuento es del 18%. Si el cliente compra más de 10 productos y el valor total de la compra es menor a 1.000.000, el descuento será del 30%, en caso contrario el descuento es del 40%.\nEscriba un programa en Python que permita calcular el valor total a pagar del cliente teniendo en cuenta las condiciones dadas anteriormente,.\n\n\nEjercicio 3\nEscribir un programa en el que se pregunte al usuario por una frase y una letra, y muestre por pantalla el número de veces que aparece la letra en la frase.\n\n\nEjercicio 4\nRealice un programa que permita resolver la siguiente sumatoria:\n$ _{i=1}{n}(n3+n^2+3) $"
  },
  {
    "objectID": "Python_Parte_2.html#funciones",
    "href": "Python_Parte_2.html#funciones",
    "title": "clases",
    "section": "## 3. Funciones",
    "text": "## 3. Funciones\nLas funciones son bloques de código que se pueden reutilizar simplemente llamando a la función.\ndef identificador(param1, param2,..):\n    inst1\n    inst2\n    .\n    .\n    return valor\nPara definir una función en Python se utiliza la palabra reservada def. A continuación viene el nombre o identificador de la función que es el que se utiliza para invocarla dentro del código. Después del nombre hay que incluir los paréntesis y una lista opcional de parámetros. Por último, la definición de la función termina con dos puntos.\nTras los dos puntos se incluye el cuerpo de la función, en donde se encuentra el conjunto de instrucciones que se encapsulan en dicha función y finalmente, de manera opcional, se añade la instrucción con la palabra reservada return para devolver un resultado.\n\ndef new_function():\n  print(\"Hola, estoy en la función\")\n\nnew_function()\n\nHola, estoy en la función\n\n\nLas funciones permiten la reutilización de código es decir, que se evita escribir nuevamente secciones de código. Esto hace que el código sea más legible, facilita la depuración y limita los errores de escritura.\n\ndef func_name(nombre):\n  print(\" Hola,\", nombre)\n\n# Importante tener en cuenta la cantidad de argumentos que la función recibira\n\nfunc_name(\"Camilo\")\nfunc_name(\"Juan\")\nfunc_name(\"Maria\")\n\n Hola, Camilo\n Hola, Juan\n Hola, Maria\n\n\n\nEjercicio 5\nRealice un programa que pida n cantidad de numeros y por medio de un mensaje, muestre si el numero es par o no.\n\n\nReferencias:\nhttps://www.w3schools.com/PYTHON/"
  },
  {
    "objectID": "Python_Parte_3.html#listas",
    "href": "Python_Parte_3.html#listas",
    "title": "clases",
    "section": "## 4.1 Listas",
    "text": "## 4.1 Listas\nLas listas son el tipo de colección más común. Son estructuras de datos ordenadas con longitud variable. Esto quiere decir, que tras su declaración se pueden agregar o eliminar elementos específicos de su contenido. Además, estos elementos ocupan una posición definida secuencialmente, siendo el primer elemento el que ocupa la posición 0.\nExisten dos formas de declarar listas en Python: * Con llaves cuadradas.    Ejemplo: l = [] * Con la función list.      Ejemplo: l = list()\nEn el momento de su definición, se pueden definir valores por defecto, separados por coma.\n\nl = [1, 'Hola', 4.5]\nprint(l)\ntype(l)\n\n[1, 'Hola', 4.5]\n\n\nlist\n\n\nLas listas en Python son:\n\nHeterogéneas: Pueden estar conformadas por elementos de distintos tipo, incluyendo otras listas.\nMutables: Sus elementos pueden modificarse.\n\n\nl = [1, 2.5, [4, 5, 6, 7], \"Fin\"]\nprint(l)\ntype(l)\n\n[1, 2.5, [4, 5, 6, 7], 'Fin']\n\n\nlist\n\n\nLos elementos de una lista pueden accederse mediante su índice, siendo 0 el índice del primer elemento.\n\nprint(l[1])\n\nHola\n\n\nSe pueden realizar operaciones entre listas mediante algunos operadores. Es importante tener en cuenta los tipos de dato, pues símbolos como estos funcionan de manera distinta en relación al tipo de dato que manejan. Estos operadores básicos son:\n\nConcatenación +: Al aplicar este operador, se agregan los elementos de la segunda lista al final de la primera.\nRepetición *: Al aplicar este operador, se repiten los elementos la cantidad de veces expresada en el segundo operando.\n\n\nl_a = [1, 2, 3]\nl_b = ['a', 'b', 'c']\n\n\n# Concatenar\n\n\n# Repetición\n\n\nAlgunos comandos de la lista de metodos:\n\n\n\n\n\n\n\nMétodos\nDescripción\n\n\n\n\nappend(elemento)\nagregar elemento al final de la lista\n\n\nextend(lis2)\nExtiende la lista con los elementos de la lista 2\n\n\nindex(element)\nDevuelve el índice más bajo de la lista que contiene el elemento.\n\n\ninsert(index,element)\nInserta un elemento para el indice index\n\n\npop(i)\nElimina y retorna el elemento en la posición i\n\n\nreverse(element)\nInvierte la lista de lugar\n\n\nremove(element)\nElimina la primera aparición del elemento de la lista\n\n\nsort()\nClasifica la lista en lugar\n\n\ncopy()\nRetorna la copia de la lista\n\n\ncount(element)\nRetorna el némero de elementos igual al elemento de la lista\n\n\n\n\n\nUtilizar los metodos:\n\n\nInterando listas\n\nlista = [\"manzana\", \"banana\", \"cereza\"]\nfor x in lista:\n  print(x)\n\nmanzana\nbanana\ncereza"
  },
  {
    "objectID": "Python_Parte_3.html#tuplas",
    "href": "Python_Parte_3.html#tuplas",
    "title": "clases",
    "section": "4.2 Tuplas",
    "text": "4.2 Tuplas\n\nSon similares a las listas, pero lo que las diferencia es que estas son inmutables, esto quiere decir que no puede modificarse de ninguna forma después de que sean creadas. Los elementos de tupla están ordenados y permiten valores duplicados. Las tuplas se pueden definir de dos formas:\n\ntupla = (1,2,3,4)\n\n# También de esta forma\n\ntupla = tuple((1, 2, 3, 4))\n\nPara acceder a un valor dada una posición se realiza igual que con las listas, se escribe el nombre de la tupla seguido de apertura de corchetes, posición que buscamos y cierre de corchetes.\n\ntupla = tuple((1,2,3, 'r'))\nprint(tupla[1])\n\n2\n\n\nSe pueden recorrer los elementos de una tupla con for:\n\nfor dato in tupla:\n    print(dato, end=\" \")\n\n1 2 3 r \n\n\n\nFunciones de las tuplas:\nLongitud de una tupla\n\ntup = (1,2,13,-50)\nlen(tup)\n\n4\n\n\nMáximo de una tupla\n\ntup = (1,2,13,-50)\nmax(tup)\n\n13\n\n\nMinimo de una tupla\n\ntup = (1,2,13,-50)\nmin(tup)\n\n-50"
  },
  {
    "objectID": "Python_Parte_3.html#set",
    "href": "Python_Parte_3.html#set",
    "title": "clases",
    "section": "## 4.3 Set",
    "text": "## 4.3 Set\nLos conjuntos se utilizan para almacenar varios elementos en una sola variable. Un conjunto es una colección desordenada , inmutable* y no indexada.\n\nNota: Los elementos establecidos no se pueden modificar, pero puede eliminar elementos y agregar elementos nuevos.\n\n\nvocales = {'a', 'e', 'i', 'o', 'u', 'a', 'a', 'o', 'e'}\nprint(vocales)\n\nDado que los conjuntos son colecciones desordenadas, en ellos no se guarda la posición en la que son insertados los elementos como ocurre en los tipos lista o tuplas. Es por ello que no se puede acceder a los elementos a través de un índice.\nSin embargo, haciendo uso de un bucle for se puede acceder y/o recorrer todos los elementos del conjunto.\n\nprint(vocales{2})\n\nSyntaxError: invalid syntax (Temp/ipykernel_1032/3960885320.py, line 3)\n\n\n\nfor e in vocales:\n    print(e)\n\nu\na\ne\ni\no\n\n\nMetodos para utilizar en conjuntos.\n\nAgregar elementos\nUna vez que se crea un conjunto, no puede cambiar sus elementos, pero puede agregar nuevos elementos. Para agregar un elemento a un conjunto, utilice el método add().\n\nconjunto = {\"manzana\", \"cereza\", \"fresa\"}\n\nconjunto.add(\"mango\")\n\nprint(conjunto)\n\n{'manzana', 'cereza', 'mango', 'fresa'}\n\n\n\n\nAgregar conjuntos\nPara agregar elementos de otro conjunto al conjunto actual, utilice el método update(), se puede tomar como argumento una lista, tupla, string, conjunto o cualquier objeto de tipo iterable.\n\nconjunto = {\"manzana\", \"cereza\", \"fresa\"}\nlista = [\"kiwi\", \"naranja\"]\n\nconjunto.update(lista)\n\nprint(conjunto)\n\n{'fresa', 'manzana', 'naranja', 'cereza', 'kiwi'}\n\n\n\nAlgunos comandos de la lista de metodos:\n\n\n\n\n\n\n\nMétodos\nDescripción\n\n\n\n\nadd()\nAñade un elemento\n\n\nclear()\nRemueve todos los elementos\n\n\ncopy()\nEntrega una copia del set\n\n\ndifference()\nEntrega un set conteniendo los miembros diferentes entre dos o más sets\n\n\ndifference_update()\nRemueve los elementos en este set que también se incluyen en otro set específico\n\n\ndiscard()\nElimina, si existe, el elemento del conjunto.\n\n\nintersection()\nEntrega un set, que es la intersección de otros dos sets\n\n\nintersec_update()\nRemueve los elementos en este set que no se encuentran presentes en otro set específico.\n\n\nisdisjoint()\nEntrega si dos sets tienen una intersección o no\n\n\nissubset()\nEntrega si otro set contiene este set o no\n\n\nissuperset()\nEntrega si este set contiene otro set o no\n\n\npop()\nObtiene y elimina un elemento de forma aleatoria del conjunto\n\n\nremove()\nElimina el elemento del conjunto. Si no existe lanza un error.\n\n\nsymmetric_difference()\nEntrega un set con la diferencia simétrica de dos sets\n\n\nunion()\nEntrega un set que contiene la unión de dos sets\n\n\nupdate()\nActualiza el set con la unión de éste y otros sets\n\n\n\n\n\n\nUnir dos conjuntos\nHay varias formas de unir dos o más conjuntos en Python.\nPuede usar el método union() que devuelve un nuevo conjunto que contiene todos los elementos de ambos conjuntos, o el método update() que inserta todos los elementos de un conjunto en otro:\n\nset1 = {\"a\", \"b\" , \"c\"}\nset2 = {1, 2, 3}\n\nset3 = set1.union(set2)\nprint(set3)\n\n{1, 2, 'a', 3, 'b', 'c'}\n\n\nEl método update() inserta los elementos en set2 en set1:\n\nset1 = {\"a\", \"b\" , \"c\"}\nset2 = {1, 2, 3}\n\nset1.update(set2)\nprint(set1)"
  },
  {
    "objectID": "Python_Parte_3.html#diccionarios",
    "href": "Python_Parte_3.html#diccionarios",
    "title": "clases",
    "section": "4.4 Diccionarios",
    "text": "4.4 Diccionarios\n\nUn diccionario de Python es una estructura de datos para almacenar grupos de objetos. Consiste en un mapeo de pares clave-valor, donde cada clave está asociada a un valor. Puede contener tipos de datos iguales o diferentes, no está ordenado y es mutable.\n\nclases = {\n    \"Analisis\": 10,\n    \"Algebra\": 25,\n    \"Fundamentos\": 30,\n    \"Discretas\": 14,\n    \"Multivariable\": 27,\n    \"Etica\": 35\n}\n\nprint(clases,\"\\n\")\nprint(clases.keys(),\"\\n\")\nprint(clases.values(),\"\\n\")\nprint(clases.items(),\"\\n\")\n\n{'Analisis': 10, 'Algebra': 25, 'Fundamentos': 30, 'Discretas': 14, 'Multivariable': 27, 'Etica': 35} \n\ndict_keys(['Analisis', 'Algebra', 'Fundamentos', 'Discretas', 'Multivariable', 'Etica']) \n\ndict_values([10, 25, 30, 14, 27, 35]) \n\ndict_items([('Analisis', 10), ('Algebra', 25), ('Fundamentos', 30), ('Discretas', 14), ('Multivariable', 27), ('Etica', 35)]) \n\n\n\n\nMetodos para diccionarios\n\n\nAgregar un elemento\nPara agregar un nuevo par de valores clave o actualizar uno existente en un diccionario de Python, puede usar el operador [ ] e ingresar la clave para actualizar o agregar y seguirlo con un = y el valor.\n\nupdate ( ): Función dedicada para agregar o actualizar un par de valores. Toma otro diccionario como argumento, lista o tupla que representa los pares de valores clave.\nsetdefault ( ): Sirve para agregar un nuevo elemento a nuestro diccionario.\npop ( ): Este método remueve específicamente una clave de diccionario y devuelve su valor correspondiente. Si no lo encuentra, devuelve error.\npopitem ( ): Este método remueve y devuelve algún par (clave, valor) del diccionario como una 2 tuplas. Lanza una excepción KeyError si el diccionario esta vació.\nget ( ): Recibe como parámetro una clave, devuelve el valor de la clave. Si no lo encuentra, devuelve un objeto none.\ncopy ( ): Retorna una copia del diccionario original.\nclear ( ): Elimina todos los ítems del diccionario dejándolo vacío.\nzip ( ): Recibe como parámetro dos elementos iterables, ya sea una cadena, una lista o una tupla. Ambos parámetros deben tener el mismo número de elementos. Se devolverá un diccionario relacionando el elemento i-esimo de cada uno de los iterables.\n\n\nclases = {\n    \"Analisis\": 10,\n    \"Algebra\": 25,\n    \"Fundamentos\": 30,\n    \"Discretas\": 14,\n    \"Multivariable\": 27,\n    \"Etica\": 35\n}\n\n# Agregar un elemento\n\n# Eliminar un elemento\n\n#Zip\n\ndic = dict(zip('abcd',[1,2,3,4]))\nprint(dic)\n\n{'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\n\n\n\nIterando en diccionarios\n\n# Imprime los key del diccionario\nfor key in clases:\n    print(key)\n\nAnalisis\nAlgebra\nFundamentos\nDiscretas\nMultivariable\nEtica\n\n\n\nprint(\"Metodo 1 \\n\")\n# Imprime los value del diccionario\nfor key in clases:\n    print(clases[key])\n\nprint(\"\")\nprint(\"Metodo 2 \\n\")\n# Otro metodo\nfor value in clases.values():\n    print(value)\n\nMetodo 1 \n\n10\n25\n30\n14\n27\n35\n\nMetodo 2 \n\n10\n25\n30\n14\n27\n35\n\n\n\n# Imprime los key y value del diccionario\nfor x, y in clases.items():\n    print(x, y)\n\nAnalisis 10\nAlgebra 25\nFundamentos 30\nDiscretas 14\nMultivariable 27\nEtica 35\n\n\n\n# Diccionario con lista\n\ngrocery_items = {\"eggs\": [3.99, 4.99, 5.50],\n                 \"banana\": 1.49,\n                 \"cheese\": 4.5,\n                 \"eggplant\": 2.5,\n                \"bread\": 3.99}\n\ns = grocery_items[\"eggs\"]\nprint(s)\ns = grocery_items[\"eggs\"][0]\nprint(s)\n\n[3.99, 4.99, 5.5]\n3.99"
  },
  {
    "objectID": "Python_Parte_3.html#excepciones",
    "href": "Python_Parte_3.html#excepciones",
    "title": "clases",
    "section": "5. Excepciones",
    "text": "5. Excepciones\nLas excepciones en Python son una herramienta muy potente que la gran mayoría de lenguajes de programación modernos tienen. Se trata de una forma de controlar el comportamiento de un programa cuando se produce un error.\nImaginemos ahora que por cualquier motivo se quieren dividir nos variables (a/b), y que por ejemplo b tiene el valor 0. Si intentamos hacer la división entre cero, este programa dará un error y su ejecución terminará de manera abrupta.\n\na = 4; b = 0\nprint(a/b)\n\nZeroDivisionError: division by zero\n\n\nUna primera aproximación al control de exepciones podria ser la siguiente:\n\na = 5\nb = 0\n# A través de esta comprobación prevenimos que se divida entre cero.\nif b!=0:\n    print(a/b)\nelse:\n    print(\"No se puede dividir!\")\n\nNo se puede dividir!\n\n\nSin embargo, en Python puedes usar los bloques try y except para manejar estos errores como excepciones.\ntry:\n    # Codigo a ejecutar\n    # Pero podria haber errores en este bloque\n    \nexcept <tipo de error>:\n    # Haz esto para manejar la excepcion\n    # El bloque except se ejecutara si el bloque try lanza un error\n    \nelse:\n    # Esto se ejecutara si el bloque try se ejecuta sin errores\n   \nfinally:\n    # Este bloque se ejecutara siempre\n\nEl bloque try es el bloque con las sentencias que quieres ejecutar. Sin embargo, podrían llegar a haber errores de ejecución y el bloque se dejará de ejecutarse.\nEl bloque except se ejecutará cuando el bloque try falle debido a un error. Este bloque contiene sentencias que generalmente nos dan un contexto de lo que salió mal en el bloque try. Siempre se debe mencionar el tipo de error que se espera, como una excepción dentro del bloque except en <tipo de error> ya que de esta manera se identifica el tipo de error que podria ocurrir.\nEl bloque else se ejecutará solo si el bloque try se ejecuta sin errores.\nEl bloque finally siempre es ejecutado sin importar que pase en los otros bloques, esto puede ser útil cuando quieras liberar recursos después de la ejecución de un bloque de código.\n\n\nNota: Los bloques else y finally son opcionales.\n\nEl ejemplo anterior, utilizando estos bloques quedaria de la siguiente manera:\n\na = 5; b = 0\ntry:\n    c = a/b\nexcept ZeroDivisionError:\n    print(\"No se ha podido realizar la división\")\n\nNo se ha podido realizar la división"
  },
  {
    "objectID": "Python_Parte_3.html#lectura-de-archivos",
    "href": "Python_Parte_3.html#lectura-de-archivos",
    "title": "clases",
    "section": "6. Lectura de archivos",
    "text": "6. Lectura de archivos\nMuchas veces necesitamos que nuestros cálculos sean escritos en un archivo externo y no solamente escritos en la consola. Para ello usamos Python file.\n\n\n\n\n\n\n\nArgumento\nDescripción\n\n\n\n\nr\nTexto, leer solamente\n\n\nw\nTexto, escribir ( si existe un archivo con el mismo nombre este lo sobreescribe)\n\n\na\nTexto, adjuntar el texto al archivo ya existente\n\n\nr+\nTexto, leer y escribir\n\n\nrb\nBinario, leer solamente\n\n\nwb\nBinario, escribir ( si existe un archivo con el mismo nombre este lo sobreescribe)\n\n\nab\nBinario, adjuntar el texto al archivo ya existente\n\n\nrb+\nBinario leer y escribir\n\n\n\n\nReferencias:\nhttps://www.freecodecamp.org/espanol/news/sentencias-try-y-except-de-python-como-menejar-excepciones-en-python/ https://www.w3schools.com/python/python_try_except.asp"
  },
  {
    "objectID": "Python_Parte_4.html#leer-base-de-datos-con-numpy",
    "href": "Python_Parte_4.html#leer-base-de-datos-con-numpy",
    "title": "clases",
    "section": "Leer base de datos con numpy",
    "text": "Leer base de datos con numpy\nVamos a trabajarlo desde Spyder sin embargo, aquí se encuentra la sintaxis de la función que nos permite cargar base de datos:\nloadtxt(fname, dtype=float, comments='#', delimiter=None,\n            converters=None, skiprows=0, usecols=None, unpack=False,\n            ndmin=0, encoding='bytes', max_rows=None, *, like=None):\nTambien, se puede utilizar la libreria Pandas\npd.read_csv('data.csv', delimiter=' ')"
  },
  {
    "objectID": "Python_Parte_5.html#libreria-matplotlib",
    "href": "Python_Parte_5.html#libreria-matplotlib",
    "title": "clases",
    "section": "# Libreria Matplotlib",
    "text": "# Libreria Matplotlib\n \nMatplotlib es una biblioteca completa para crear visualizaciones estáticas, animadas e interactivas en Python\nPara poder usar Matplotlib primero debemos instalarlo ya que es modulo externo. Por ejemplo, si se esta trabajando Python en conda, se debe abrir la terminal (Anaconda Prompt) y escribir conda install matplotlib.\nEn la pagina principal de Matplotlib encontraras mas funciones para graficar. En el siguiente link, se encuentran un CheatSheets de esta libreria https://matplotlib.org/cheatsheets/cheatsheets.pdf\nUna vez instalado, la forma más común de importar esta librería en nuestro archivo de trabajo es utilizando el alias plt. También, se suele utilizar la libreria numpy para crear los vectores.\n\n# Importar las librerias necesarias\nimport matplotlib\nimport numpy as np"
  },
  {
    "objectID": "Python_Parte_5.html#colores",
    "href": "Python_Parte_5.html#colores",
    "title": "clases",
    "section": "Colores",
    "text": "Colores\n \nTomado de: https://matplotlib.org/stable/tutorials/colors/colors.html#sphx-glr-tutorials-colors-colors-py\n\nTipos de línea\n\n\n\nCódigo\nTipo de línea\n\n\n\n\n-\nSolida\n\n\n–\nA trozos\n\n\n:\nPunteada\n\n\n\n\n\nTipos de marcadores\n\n\n\nCódigo\nMarca\nDescripción\n\n\n\n\n\\(.\\)\n\\(.\\)\nPunto\n\n\nO\n\\(o\\)\nCirculo\n\n\n+\n\\(+\\)\nMas\n\n\nX\n\\(\\times\\)\nCruz\n\n\nD\n\\(\\diamond\\)\nCiamante\n\n\nS\n\\(\\square\\)\nCuadrado\n\n\n*\n\\(\\star\\)\nEstrella\n\n\n\n\n\nUbicación de la leyenda\n\n\n\nString\ninteger\n\n\n\n\n‘best’\n0\n\n\n‘upper rigth’\n1\n\n\n‘upper ledft’\n2\n\n\n‘lower left’\n3\n\n\n‘lowe right’\n4\n\n\n‘right’\n5\n\n\n‘center left’\n6\n\n\n‘center rigth’\n7\n\n\n‘lower center’\n8\n\n\n‘upper center’\n9\n\n\n‘center’\n10"
  },
  {
    "objectID": "Python_Parte_5.html#figura",
    "href": "Python_Parte_5.html#figura",
    "title": "clases",
    "section": "Figura",
    "text": "Figura\n\nfig = plt.figure()  # Crear figura vacia sin ejes\nfig, ax = plt.subplots()  # Figura con un solo eje\nfig, axs = plt.subplots(2, 3)  # Figura con una cuadrícula de 2x2\n\n<Figure size 432x288 with 0 Axes>"
  },
  {
    "objectID": "Python_Parte_5.html#grafico-sencillo",
    "href": "Python_Parte_5.html#grafico-sencillo",
    "title": "clases",
    "section": "Grafico sencillo",
    "text": "Grafico sencillo\nLa forma más sencilla de crear una Figura con Ejes es usando pyplot.subplots\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()  # Crea una figura que contenga un solo eje.\nax.plot([1, 2, 3, 4], [1, 4, 2, 3]);  # Grafica datos en los ejes."
  },
  {
    "objectID": "Python_Parte_5.html#graficar-puntos",
    "href": "Python_Parte_5.html#graficar-puntos",
    "title": "clases",
    "section": "Graficar puntos",
    "text": "Graficar puntos\nUtilizamos la función scatter(x, y): Dibuja un diagrama de puntos con las coordenadas de la lista x en el eje X y las coordenadas de la lista y en el eje Y.\nUtilizando la función plt.savefig('---.png') podemos guardar el gráfico en formato png\n\n# Crear la figura y los ejes\nfig, ax = plt.subplots()\n# Dibujar puntos\nax.scatter(x = [1, 2, 3, 4, 5, 6, 7], y = [3, 2, 1, 4, 6, 2, 1], c=\"r\")\n# Guardar el gráfico en formato png\nplt.savefig('diagrama-dispersion.png')\n# Mostrar el gráfico\nplt.show()\n\n\n\n\nOtro ejemplo\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nN = 50\nx = np.random.rand(N)\ny = np.random.rand(N)\ncolors = np.random.rand(N)\narea = (30 * np.random.rand(N))**2  # 0 to 15 point radii\n\nplt.scatter(x, y, s=area, c=colors, alpha=0.5)\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#grafica-de-funciones",
    "href": "Python_Parte_5.html#grafica-de-funciones",
    "title": "clases",
    "section": "Grafica de funciones",
    "text": "Grafica de funciones\n\n#Crea el vecto x con 50 valores equidistantes\nx = np.linspace(0,20,50) \n# Crea el vector y\ny= np.sin(x)\n \nc = plt.plot(x, y, 'c-3', linewidth = 2, label=\"sen(x)\")\nplt.legend(loc=3)\n \n\n<matplotlib.legend.Legend at 0x7fe026c4e150>"
  },
  {
    "objectID": "Python_Parte_5.html#graficar-otra-función",
    "href": "Python_Parte_5.html#graficar-otra-función",
    "title": "clases",
    "section": "Graficar otra función",
    "text": "Graficar otra función\nEn esta grafica tenemos puntos y ademas, graficamos una función.\n\n#Crea el vecto x con 30 valores equidistantes\nx = np.linspace(0,20,30) \n# Crea el vector y\ny= np.array(x**0.5)\n\nplt.scatter(x,y,color=\"green\")\nc = plt.plot(x, y, '-', color=\"red\", linewidth = 2, label=\"x^0.5\")\n# Se ingresa la posición donde se quiere ubicar la leyenda de la grafica\nplt.legend(loc=4)\n\n \n\n<matplotlib.legend.Legend at 0x7fe0273877d0>"
  },
  {
    "objectID": "Python_Parte_5.html#estilos",
    "href": "Python_Parte_5.html#estilos",
    "title": "clases",
    "section": "Estilos",
    "text": "Estilos\nSe tienen dos metodos esenciales para trabajar con matplotlib.\n\nCrear explícitamente figuras y ejes, llamando metodos en ellos.\n\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\n# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.plot(x, x, label='linear')  # Plot some data on the axes.\nax.plot(x, x**2, label='quadratic')  # Plot more data on the axes...\nax.plot(x, x**3, label='cubic')  # ... and some more.\nax.set_xlabel('x label')  # Add an x-label to the axes.\nax.set_ylabel('y label')  # Add a y-label to the axes.\nax.set_title(\"Simple Plot\")  # Add a title to the axes.\nax.legend();  # Add a legend.\n\n\n\n\n\nConfiar en pyplot para crear y administrar automáticamente las figuras y los ejes, utilizando las funciones de pyplot para trazar.\n\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7))\nplt.plot(x, x, label='linear')  # Plot some data on the (implicit) axes.\nplt.plot(x, x**2, label='quadratic')  # etc.\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend();"
  },
  {
    "objectID": "Python_Parte_5.html#diagramas-de-areas",
    "href": "Python_Parte_5.html#diagramas-de-areas",
    "title": "clases",
    "section": "Diagramas de areas",
    "text": "Diagramas de areas\nfill_between(x, y): Dibuja el area bajo el polígono con los vértices dados por las coordenadas de la lista x en el eje X y las coordenadas de la lista y en el eje Y.\n\nfig, ax = plt.subplots()\nax.fill_between([1, 2, 3, 4], [1, 2, 0, 0.5])\nplt.show()\n\n\n\n\nPodemos modificar el color añadiendo otro parametro en la función fill_between(x, y, facecolor=\"Name_Color\"):\n\nfig, ax = plt.subplots()\nax.fill_between([1, 2, 3, 4], [1, 2, 0, 0.5], facecolor=\"r\")\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#anotar",
    "href": "Python_Parte_5.html#anotar",
    "title": "clases",
    "section": "Anotar",
    "text": "Anotar\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2 * np.pi * t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\nax.set_ylim(-2, 2);"
  },
  {
    "objectID": "Python_Parte_5.html#matplotlib-subplot",
    "href": "Python_Parte_5.html#matplotlib-subplot",
    "title": "clases",
    "section": "Matplotlib Subplot",
    "text": "Matplotlib Subplot\nSintaxis:\nsubplot(numRows, numCols, plotNum)\n\n* numRows = Número de filas\n* numCols = Número de columnas\n* plotNum = Número de gráfica\n\n#plot 1:\nx = np.array([0, 1, 2, 3])\ny = np.array([3, 8, 1, 10])\n\nplt.subplot(3, 1, 1)\nplt.plot(x,y)\nplt.title(\"Plot 1\")\n\n#plot 2:\nx = np.array([0, 1, 2, 3])\ny = np.array([10, 20, 30, 40])\n\nplt.subplot(3, 1, 3)\nplt.plot(x,y)\nplt.title(\"Plot 2\")\n\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#grafica-en-coordenadas-polares",
    "href": "Python_Parte_5.html#grafica-en-coordenadas-polares",
    "title": "clases",
    "section": "Grafica en coordenadas polares",
    "text": "Grafica en coordenadas polares\n\ntheta = np.linspace(0, 2.*np.pi, 1000)\na = 1.\nr = 2 * a * (1. + np.cos(theta))\nplt.polar(theta, r)\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#diagrama-de-barras",
    "href": "Python_Parte_5.html#diagrama-de-barras",
    "title": "clases",
    "section": "Diagrama de Barras",
    "text": "Diagrama de Barras\n\nx = np.array([\"A\", \"B\", \"C\", \"D\"])\ny = np.array([3, 8, 1, 10])\n\nplt.bar(x, y, color=\"c\")\n\n## Leyenda en el eje x\nplt.xlabel('Grupos')\n\n## Leyenda en el eje y\nplt.ylabel('Cantidad')\n \n## Título de Gráfica\nplt.title('Grafica')\n\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#diagrama-de-torta",
    "href": "Python_Parte_5.html#diagrama-de-torta",
    "title": "clases",
    "section": "Diagrama de torta",
    "text": "Diagrama de torta\n\ny = np.array([35, 25, 25, 15])\nmylabels = [\"Apples\", \"Bananas\", \"Cherries\", \"Dates\"]\n\nplt.pie(y, labels = mylabels)\nplt.show()"
  },
  {
    "objectID": "Terminado_Introduccion_a_Python_Parte_1.html#entrada-y-salida",
    "href": "Terminado_Introduccion_a_Python_Parte_1.html#entrada-y-salida",
    "title": "clases",
    "section": "2. Entrada y salida",
    "text": "2. Entrada y salida\nLos programas escritos en Python y los entornos de ejecución (como Google Colab) permiten al usuario interactuar de formas distintas. El usuario introduce información en forma de archivos, datos en la nube, o acciones de periféricos como el teclado y ratón, y los entornos de ejecución ejecutan el programa de Python. En consecuencia, le devuelven al usuario una respuesta en forma de texto, imagen o contenidos interactivos complejos. A continuación, conocera las funciones de entrada y salida de texto. Las más comunes y más útiles en los primeros pasos del aprendizaje del lenguaje son las funciones input y print.\nCuando se ejecuta input() la consola de Python espera que se le entregue texto, que puede escribir con su teclado o pegar del portapapeles, para luego hacer algo con este, como almacenarlo en una variable. Por otro lado, print() escribirá en consola texto que este almacenado previamente.\n\nnombre = input('Hola. ¿Cómo te llamas?\\n')\n\nHola. ¿Cómo te llamas?\nisa\n\n\n\nprint(\"¿Cómo se llama?\")\nnombre = input()\nprint(\"¿Cual es su edad?\")\nedad = input()\nprint(f\"Me alegro de conocerle, {nombre}\")\nprint(f\"Con {edad} años\")\n\n¿Cómo se llama?\nisa\n¿Cual es su edad?\n3\nMe alegro de conocerle, isa\nCon 3 años\n\n\nNota: De forma predeterminada, la función input() siempre que lee algún dato, lo retorna como un string, incluso aunque sea un número válido y por ejemplo, si intentamos hacer operaciones, se producirá un error.\n\ncantidad = input(\"Dígame una cantidad en pesetas: \")\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nDígame una cantidad en pesetas: jm\n\n\nTypeError: ignored\n\n\nPara evitar lo mencionado anteriormente, se debe convertir el dato a número (float o int) según lo que se requiera en el programa. Veamos entonces cómo leer y convertir los números de la entrada en Python.\nEjemplo: Si se quiere que Python interprete la entrada como un número entero, se debe utilizar la función int() de la siguiente manera:\n\ncantidad = int(input(\"Dígame una cantidad en pesetas: \"))\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nDígame una cantidad en pesetas: 40\n40 pesetas son 0.24 euros\n\n\nEjemplo: Modifique el código anterior de tal manera que Python interprete la entrada como un float e imprima el valor con un redondeo de 3 dígitos."
  },
  {
    "objectID": "Terminado_Introduccion_a_Python_Parte_1.html#tipos-de-dato-y-operadores",
    "href": "Terminado_Introduccion_a_Python_Parte_1.html#tipos-de-dato-y-operadores",
    "title": "clases",
    "section": "3. Tipos de dato y operadores",
    "text": "3. Tipos de dato y operadores\n\nEl tipo de un dato es un atributo que determina qué operaciones se pueden realizar y qué valores puede tomar. Estos pueden ser números, listas, texto, entre otros. En Python, los tipos de dato no son definidos explícitamente, pero siempre están presentes en las variables que declaramos y es necesario tenerlos en cuenta. En particular, el tipo de dato define las operaciones válidas entre datos del mismo tipo. Estas operaciones están definidas con el uso de símbolos llamados operadores.\nPara conocer el tipo de dato de una variable, se usa la función type.\n\nnum = 40\nprint(type(num))\nPersona = 3\n\n<class 'int'>"
  },
  {
    "objectID": "Terminado_Introduccion_a_Python_Parte_1.html#cadenas-de-texto",
    "href": "Terminado_Introduccion_a_Python_Parte_1.html#cadenas-de-texto",
    "title": "clases",
    "section": "### 3.1. Cadenas de texto",
    "text": "### 3.1. Cadenas de texto\nUn tipo de dato muy importante es el de las cadenas de texto. Estas cadenas permiten almacenar en un mismo dato texto con cualquier cantidad de caracteres. Para definir una cadena de texto, se rodea el texto con comillas simples ' o comillas dobles \".\n\n'cadena con comilla simple'\n\n'cadena con comilla simple'\n\n\n\n\"cadena con comillas dobles\"\n\n'cadena con comillas dobles'\n\n\nLas cadenas se pueden almacenar en variables, así:\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\n\n\nprint(c)\n\n ¡Pontificia Universidad Javeriana Cali! \n\n\nAlgunos operadores de los usados para valores numéricos también sirven al operar con strings pero con utilidad distinta:\n\nConcatenación +.\nRepetición *.\nFormato %.\n\n\nConcatenación\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\nname = \" Andres \"\nc + name\n\n' ¡Pontificia Universidad Javeriana Cali!  Andres '\n\n\n\n\nRepetición\n\nname * 3\n\n' Andres  Andres  Andres '\n\n\n\n\nFormato\nEste operador permite reemplazar los marcadores de posición (%_) dentro de la string con la o las variables que se encuentren después del operador (%).\n\ntipo_calculo = \"raíz cuadrada de dos\"\nvalor = 2**0.5\nprint (\"el resultado de %s es %f\" % (tipo_calculo, valor))\n\nel resultado de raíz cuadrada de dos es 1.414214\n\n\nLas cadenas, como objetos que son, nos proporcionan métodos que nos facilitan su manipulación. Por ejemplo, siendo s una variable con un string:\n\ns.lower() : Retorna la cadena con todos los caracteres alfabéticos en minúscula.\ns.upper() : Retorna la cadena con todos los caracteres alfabéticos en mayúscula.\ns.replace(a, b) : Reemplaza las subcadenas iguales a la cadena a con el valor de la cadena b.\ns.strip() : Retorna la cadena con todos los espacios en blanco al principio y al final removidos.\ns.islower() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isupper() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isdigit() : Determina si la cadena está compuesta solo por dígitos del 0 al 9.\ns.isalpha() : Determina si la cadena está compuesta solo por caracteres alfabéticos.\n\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\nc.lower()\nc.upper()\nc.replace('a','x')\n#c.strip()\n#c = c.upper()\n#print(c)\n\n' ¡Pontificix Universidxd Jxverixnx Cxli! '\n\n\nCada uno de los caracteres de una cadena (incluidos los espacios) tiene asignado un índice. Este indice nos permite seleccionar su carácter asociado haciendo referencia a él entre corchetes ([ ])\n\n\n\nimage.png\n\n\n\nc = '¡Pontificia Universidad Javeriana Cali!'\nc[:3]\nc[-1]\n\n'!'\n\n\n\n\n3.2. Valores y operadores numéricos\n\nEn Python, los valores numéricos pueden ser de tres formas:\n\nNúmeros enteros. (int)\nNúmeros decimales. (float)\nNúmeros complejos. (complex)\n\n\na = 10            #int\nprint(a)\nprint(type(a))\n\n10\n<class 'int'>\n\n\n\na = -1089         #int - Se pueden escribir números negativos con el símbolo ‘-’\nprint(a)\nprint(type(a))\n\n-1089\n<class 'int'>\n\n\n\na = 1e100         #float - Esta sintaxis representa notación científica.\nprint(a)\nprint(type(a))\n\n1e+100\n<class 'float'>\n\n\n\na = 1 + 0.2j      #complex\nprint(a)\nprint(type(a))\n\n(1+0.2j)\n<class 'complex'>\n\n\nComo obtener la parte real e imaginaria de un numero complejo:\n\n(2.0+8.0j).real\n\n2.0\n\n\n\n(4.0+5.3j).imag\n\n5.3\n\n\n\na = 2.0+8.0j\nb = 4.0+5.3j\n(a+b).imag\n\n13.3\n\n\nExisten varios operadores matemáticos para estos valores numéricos. Estos son:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n+\nSuma\n\n\n*\nMultiplicación\n\n\n/\nDivisión de numeros flotantes\n\n\n//\nDivisión de números enteros\n\n\n%\nMódulo\n\n\n**\nExponencial\n\n\n\n\n3**2\n\n9\n\n\n\n12%2\n\n0"
  },
  {
    "objectID": "Terminado_Introduccion_a_Python_Parte_1.html#operados-logicos",
    "href": "Terminado_Introduccion_a_Python_Parte_1.html#operados-logicos",
    "title": "clases",
    "section": "Operados logicos",
    "text": "Operados logicos\nOtro tipo de dato importante es el booleano, que representa un valor lógico de verdad. Puede tomar únicamente estos dos valores:\n\nVerdadero: True\nFalso: False\n\nEn Python, a diferencia de otros lenguajes de programación, las primitivas lógicas son escritas con la primera letra en mayúscula.\nAdemás de con el uso de las dos primitivas lógicas (True y False), se pueden obtener valores lógicos con la evaluación de expresiones con operadores relacionales. Los cuales se encuentran a continuación:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n==\nIgual\n\n\n!=\nDiferente\n\n\n<\nMenor que\n\n\n<=\nMenor igual que\n\n\n\\(>\\)\nMayor que\n\n\n\\(>=\\)\nMayor e igual que\n\n\n\n\nprint(-10  >   4.0)  # Mayor que.   \n\nFalse\n\n\n\nprint(-10  !=  4.0)  # Distinto que.\n\nTrue\n\n\n\na = 'Michele'\nb = 'Santi'\na < b\nb != a\n\nTrue\n\n\n¿Puedo utilizar los operadores lógicos con string?\nPara evaluar más de una condición simultáneamente, se utilizan operadores lógicos. Estos son:\n\nAND lógico. and\nOR lógico. or\nNOT. negación. not\n\nEjemplo\n\na = True\nb = False \nc = True\n\nprint(a or b)\n\nTrue\n\n\nAdemás de estos operadores, se puede usar el operador is, que valida la identidad de un objeto. Para entender esto, tenemos que por su parte el operador == valida la igualdad de contenido de un objeto, mientras que el operador is valida si dos objetos, además de ser iguales en contenido, contienen la misma referencia en memoria, es decir, valida si son el mismo objeto. Si los valores son primitivas numéricas o lógicas el operador is retornará True.\n\n# Operador is\n\nprint('Operador is')\na = 1.0\nb = 1\n\nprint(a is b) # No tienen el mismo tipo de dato y por lo tanto son objetos distintos.\nprint(a == b) # Contienen el mismo valor al verificar su igualdad.\n\nOperador is\nFalse\nTrue"
  },
  {
    "objectID": "Intalacion.html",
    "href": "Intalacion.html",
    "title": "Instalación Phyton",
    "section": "",
    "text": "Intalación de python\nAntes de comenzar debemos instalar python en nuestro equipo\n\nVamos a la pagina oficial de anaconda y descargamos ultima vesrio de este software https://www.anaconda.com/products/individual\nInstalamos el software en nuestro equipo\nAbrimos una terminal y vamosa crear un entorno virtual para trabajar con python\n\n\nconda create -n python3 python=3.8\nAhora vamos a entrar al entornode trabajo\nconda activate python3\nNote que el nombre del entorno de trabajo aparece entre parentesis en la terminal. Ahora vamos a instalar jupyter notebook\nconda install -c conda-forge notebook\npara instalar la libreria numpy\nconda install -c anaconda numpy\nDesde la terminal podemos ejecutar jupyter notebook\njupyter notebook\nEsto nos abrira una ventana en el navegador donde podemos crear un nuevo notebook\n\n\n\njupyter"
  },
  {
    "objectID": "Python_numpy.html",
    "href": "Python_numpy.html",
    "title": "Errores",
    "section": "",
    "text": "import numpy as np\n\na=np.matrix([[1, 2], [3, 4]])\na.shape\n\n(2, 2)\n\n\n\n# otra forma de imprimir una matriz\na = np.matrix('1 2; 3 4')\na\n\nmatrix([[1, 2],\n        [3, 4]])\n\n\n\n#tomar la primera fila de la matriz\nprint(a[0])\n\n[[1 2]]\n\n\n\nprint(a[0][:])\n\n[[1 2]]\n\n\n\nprint(a[:,1])\n\n[[2]\n [4]]\n\n\n\n# 1st argument --> numbers ranging from 0 to 9, \n# 2nd argument, row = 2, col = 3\narray = np.random.randint(10, size=(5, 5))\nprint(array)\n\n[[7 6 5 8 4]\n [6 3 7 4 3]\n [7 8 9 0 1]\n [5 0 9 4 0]\n [0 2 2 1 6]]\n\n\n\narray[2:,:]\n\narray([[7, 8, 9, 0, 1],\n       [5, 0, 9, 4, 0],\n       [0, 2, 2, 1, 6]])\n\n\n\n# escoger una submatriz de una matriz array\n\narray[1:3, 1:3 ]\n\narray([[8, 7],\n       [0, 5]])\n\n\n\n# escojemos las columnas impares y filas pares\n\narray[::2, 1::2]\n\narray([[6, 8],\n       [8, 0],\n       [2, 1]])\n\n\n\n# multiplicar dos matrices \n\nA=np.array([[1,2],[3,4]])\nB=np.array([[5,6],[7,8]])\nA@B\n\narray([[19, 22],\n       [43, 50]])\n\n\n\n\n# Vector fila\nvector_fila = np.array([1, 2, 3, 4, 5])\n\n# Redimensionar a un vector columna\nvector_columna = vector_fila[:, np.newaxis]\n\nprint(vector_columna)\nvector_columna.\n\n[[1]\n [2]\n [3]\n [4]\n [5]]\n\n\n\n# Transpuesta de una matriz     A.T\nA.T\n\narray([[1, 3],\n       [2, 4]])\n\n\n\n# producto punto de dos vectores\na=np.array([1,2,3])\nb=np.array([4,5,6])\nprint(a.dot(b))\nprint(np.dot(a,b))\n\n32\n32\n\n\n\n# producto de un numero por un array\n5 * a\n\narray([ 5, 10, 15])\n\n\n\n# producto elemento a elemento\na*b\n\narray([ 4, 10, 18])\n\n\n\n# potenciacion de un array\n\na**2\n\narray([1, 4, 9])\n\n\n\nnp.sin(a)\n\narray([0.84147098, 0.90929743, 0.14112001])\n\n\n\n#crear una matriz de ceros \nA=np.zeros((3,3))\n# crear una matriz de unos\nB=np.ones((3,3))\n\n\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef imagen_a_matriz(ruta_imagen):\n    # Abrir la imagen\n    imagen = Image.open(ruta_imagen)\n    # convertir a blanco y negro\n    imagen = imagen.convert(\"L\")\n    # Convertir la imagen a una matriz NumPy\n    matriz = np.array(imagen)\n\n    return matriz\n\n# Ruta de la imagen que quieres convertir a matriz\nruta_imagen = \"img.png\"\n\n# Llamar a la función para convertir la imagen a matriz\nmatriz_imagen = imagen_a_matriz(ruta_imagen)\n\n# Imprimir la matriz resultante\nprint(matriz_imagen)\nplt.imshow(matriz_imagen, cmap='gray') \n\n[[255 255 255 ... 255 255 255]\n [255 255 255 ... 255 255 255]\n [255 255 255 ... 255 255 255]\n ...\n [255 255 255 ... 255 255 255]\n [255 255 255 ... 255 255 255]\n [255 255 255 ... 255 255 255]]\n\n\n<matplotlib.image.AxesImage at 0x7fbcb89f0ad0>\n\n\n\n\n\n\ncual es la dimension de la matriz\nCrear una nueva matriz con solo los elementos pares de las filas y elementos impares de las columnas\nCrear una matriz con solo los elementos que muestren la nariz del animal"
  },
  {
    "objectID": "Python_numpy.html#si-la-aproximación-se-hace-mediante-redondeo-se-dice-que",
    "href": "Python_numpy.html#si-la-aproximación-se-hace-mediante-redondeo-se-dice-que",
    "title": "Errores",
    "section": "Si la aproximación se hace mediante redondeo, se dice que:",
    "text": "Si la aproximación se hace mediante redondeo, se dice que:\n\\(x_n\\) aproxima a \\(x\\) con un \\(k\\) dígitos decimales, si \\(k\\) es el mayor entero negativo tal que \\[e_n\\leq \\frac{1}{2}\\times 10^{-k}\\]\n\\(x_n\\) aproxima a \\(x\\) con un \\(k\\) cifras significativas, si \\(k\\) es el mayor entero negativo tal que \\[\\epsilon_n\\leq \\frac{10^{-k}}{2}\\]\n\nInstala la librería pandas matplotlib usando anaconda desde enviroments\nImporta la librería pandas\nimporta la librería matplotlib.pyplot\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Crear un DataFrame vacío con las columnas deseadas\ncolumnas = [\"iteracion\", \"valor\", \"error absoluto\", \"error relativo\"]\ndf = pd.DataFrame(columns=columnas)\n\n# Imprimir el DataFrame vacío\nprint(df)\n\nEmpty DataFrame\nColumns: [iteracion, valor, error absoluto, error relativo]\nIndex: []\n\n\n\nfor i in range(1,10):\n    df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n\n# Imprimir el DataFrame actualizado\nprint(df)\n\n    iteracion     valor  error absoluto  error relativo\n0         1.0  0.000000        1.000000        0.010000\n1         2.0  0.500000        0.500000        0.010000\n2         3.0  0.666667        0.333333        0.010000\n3         4.0  0.750000        0.250000        0.010000\n4         5.0  0.800000        0.200000        0.010000\n5         6.0  0.833333        0.166667        0.010000\n6         7.0  0.857143        0.142857        0.010000\n7         8.0  0.875000        0.125000        0.010000\n8         9.0  0.888889        0.111111        0.010000\n9         1.0  1.000000        1.000000        2.000000\n10        2.0  1.500000        0.500000        1.000000\n11        3.0  1.666667        0.333333        0.666667\n12        4.0  1.750000        0.250000        0.500000\n13        5.0  1.800000        0.200000        0.400000\n14        6.0  1.833333        0.166667        0.333333\n15        7.0  1.857143        0.142857        0.285714\n16        8.0  1.875000        0.125000        0.250000\n17        9.0  1.888889        0.111111        0.222222\n\n\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n\n\n\n# Graficar la columna \"Valor\"\nplt.plot(df['iteracion'], df['error absoluto'], marker='o',linestyle='none',  color='b')\n\n# Personalizar la gráfica\nplt.title('Gráfico del error relativo vs iteración')\nplt.xlabel('Iteración')\nplt.ylabel('Error absoluto')\nplt.grid(True)\n\n\n\n\n\ngenere una gráfica del error relativo.\n\nGenere un codigo para aproximar la función\n\\[e^5  =\\lim_{m\\to \\infty }S_m, \\text{ donde } S_m=\\sum_{n=0}^{m} \\frac{5^n}{n!}\\]\n\nmuestre las primeras 10 aproximaciones\nmuestre una gráfica del error absoluto y relativo de cada aproximación"
  },
  {
    "objectID": "Python_numpy.html#ejemplo",
    "href": "Python_numpy.html#ejemplo",
    "title": "Errores",
    "section": "Ejemplo",
    "text": "Ejemplo\nSe quiere calcular el área de un rectángulo con base \\(b\\) y altura \\(h\\). Se miden las dimensiones del rectángulo y se obtienen los valores \\(b = 2.5 \\pm 0.1\\) y \\(h = 3.0 \\pm 0.1\\). El área del rectángulo es \\(A = b \\times h\\). ¿Cuál es el valor de \\(A\\) y cuál es su incertidumbre?\nNote que aquí se la incertidumbre seria de 0.01. Ahora si calculamos el perimetro del rectangulo, el cual es \\(P = 2b + 2h\\), la incertidumbre seria de 0.4. Esto se debe a que el error se propaga a traves de la suma.\n** Buscamos crear algoritmos donde el error se propague de manera controlada. **"
  },
  {
    "objectID": "Python_numpy.html#ejemplo-1",
    "href": "Python_numpy.html#ejemplo-1",
    "title": "Errores",
    "section": "Ejemplo 1",
    "text": "Ejemplo 1\nSean las sucesiones \\(\\{a_n\\}\\) y \\(\\{b_n\\}\\) definidas por\n\\[a_n = \\frac{n+1}{n^2} \\quad \\text{y} \\quad b_n = \\frac{n+3}{n^3}\\]\nnote que ambas sucesiones convergen a cero. Sea \\(\\hat{a}_n=\\frac{1}{n}\\) y \\(\\hat{b}_n=\\frac{1}{n^2}\\)\n\\[|a_n-0|=\\frac{n+1}{n^2}\\leq \\frac{n+n}{n^2}=2\\frac{1}{n}=2\\hat{a}_n\\]\ny\n\\[ |b_n-0|=\\frac{n+3}{n^3}\\leq \\frac{n+3n}{n^3}=4\\frac{1}{n^2}=4\\hat{b}_n\\]\nde modo que\n\\[a_n=0+O\\Big(\\frac{1}{n}\\Big) \\quad \\text{y} \\quad b_n=0+O\\Big(\\frac{1}{n^2}\\Big)\\]\nEsto quiere decir que la rápidéz de convergencia de \\(\\{b_n\\}\\) es mayor que la de \\(\\{a_n\\}\\)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nx=np.linspace(0,1,10)\ny1=1/x\ny2=1/x**2\nplt.plot(x,y1,'r--',x,y2,'b--')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('velocidad de comparación')\nplt.legend(['y=1/x','y=1/x^2'])\nplt.show()\n\n/tmp/ipykernel_101551/3491951731.py:4: RuntimeWarning: divide by zero encountered in divide\n  y1=1/x\n/tmp/ipykernel_101551/3491951731.py:5: RuntimeWarning: divide by zero encountered in divide\n  y2=1/x**2\n\n\n\n\n\nSuponga que \\(\\lim_{h\\to 0}G(h)=0\\) y \\(\\lim_{h\\to 0}F(h)=L\\). Si existe una constate positiva \\(K\\) tal que\n\\[|F(h)-L|\\leq K|G(h)|\\]\npara todo \\(h\\) suficientemente pequeño \\(0\\), entonces\n\\(F(h)=L+O\\Big(G(h)\\Big)\\)."
  },
  {
    "objectID": "biseccion.html",
    "href": "biseccion.html",
    "title": "Método de la bisección",
    "section": "",
    "text": "Método de la bisección para encontrar raíces de una ecuación\nSea una función \\(f(x)\\) continua en un intervalo \\([a,b]\\) tal que \\(f(a)\\) y \\(f(b)\\) tienen signos opuestos. Entonces existe al menos un número c en (a,b) tal que \\(f(c)=0\\).\n\n\n\nMétodo\n\n\nEl método de la bisección consiste en dividir el intervalo por la mitad y seleccionar el subintervalo que tiene signos opuestos en los extremos. Este proceso se repite hasta que el intervalo sea lo suficientemente pequeño. Note que este es un algoritmo iterativo, por ende, necesitamos algunos criterios de parada. ¿Cuáles criterios de parada podemos usar?\n\nEjericio:\n\nGrafique la función \\(f(x)=x^3-2x^2+3x-1\\) en el intervalo \\([0,1]\\).\n¿Qué criterios de parada podemos usar para este método?\nNote que esta función tiene una raíz en el intervalo \\([0,1]\\). Intente escribir un algoritmo para implementar el método de la bisección para encontrar la raíz de la función.\nCompare ese algoritmo con el siguiente:\n\n\nEntrada Extremos \\(a,b\\) del intervalo, tolerancia \\(TOL\\), número máximo de iteraciones \\(N_0\\).\nSalida Aproximación \\(p\\) de la raíz de \\(f(x)\\) tal que satisfaga el criterio de parada o un mensaje de error.\nPaso 1. Tome \\(i=1\\); \\[FA=f(a);\\]\nPaso 2. Mientras \\(i\\leq N_0\\) haga paso 3-6\nPaso 3. \\(p=a+(b-a)/2\\); (cálcule \\(p_i\\)) \\[FP=f(p);\\]\nPaso 4. Si \\(f(p)=0\\) o \\((b-a)/2<TOL\\) entonces\nSalida (\\(p\\)); (la salida es \\(p_i\\))\nPaso 5. \\(i=i+1\\);\nPaso 6. Si \\(FA\\cdot FP>0\\) entonces \\[a=p;\\ \\ FA=FP\\] Si no \\[b=p;\\] Paso 7. Salida (Fracaso, el número máximo de iteraciones fue excedido)\n\n\nEjercicio 2:\nImplemente el método de la bisección para encontrar la raíz de la función \\(f(x)=x^3-2x^2+3x-1\\) en el intervalo \\([0,1]\\) y genere una tabla como la siguiente\nIteración | \\(a_n\\) | \\(b_n\\) | \\(p_n\\) | \\(f(p_n)\\) | \\(Error_{absoluto}\\) |\\(Error_{relativo}\\)|\n\n## Método de la bisección\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef f(x):\n    return x**3 + 4*x**2 - 10\n\ndef biseccion(a, b, tol, max_iter):\n    if f(a)*f(b) < 0:\n        i = 0\n        while i < max_iter:\n            c = (a + b)/2\n            if f(c) == 0 or (b - a)/2 < tol:\n                return c\n            i += 1\n            if f(a)*f(c) > 0:\n                a = c\n            else:\n                b = c\n        return c\n    else:\n        print(\"No hay raíz en el intervalo\")\n\n\n\nTeorema\nSuponga que \\(f\\) es continua en \\([a,b]\\) y que \\(f(a)\\) y \\(f(b)\\) tienen signos opuestos. El método de bisección produce una secuencia de intervalos \\(\\{p_n\\}\\) que convergen a un número \\(p\\) tal que \\(f(p)=0\\), tal que \\[|p_n-p|\\leq \\frac{b-a}{2^n}\\]\nEjercicio compruebe esta afirmación numericamente"
  },
  {
    "objectID": "newton.html",
    "href": "newton.html",
    "title": "Newton Rapshon",
    "section": "",
    "text": "Método de Newton Rapshon\n\n\n\nMétodo de Newton\n\n\nForma gráfica\nEl método de Newton-Raphson es un método de segundo orden para encontrar raíces de una función \\(f(x)\\), es decir, encontrar \\(x\\) tal que \\(f(x)=0\\). Para obtener el algoritmo del método vamos a usar el desarrollo de Taylor de \\(f(x)\\) alrededor de \\(x_0\\):\n\\[f(x) = f(x_0) + f'(x_0)(x-x_0) + \\frac{f''(x_0)}{2!}(x-x_0)^2 + \\frac{f'''(x_0)}{3!}(x-x_0)^3 + \\cdots\\] truncando la serie a primer orden y despejando \\(x\\) obtenemos: \\[0=f(x_0) + f'(x_0)(x-x_0)+O(|x-x_0|^2)\\] Note que aquí podemos construir una función \\[g(x) = f(x_0) + f'(x_0)(x-x_0)\\] que pasa por el punto \\((x_0,f(x_0))\\) y tiene pendiente \\(f'(x_0)\\), es decir, es la recta tangente a \\(f(x)\\) en \\(x_0\\), de esta forma podemos definir \\(x_1\\) como la intersección de \\(g(x)\\) con el eje \\(x\\), de donde \\[x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)}\\] de forma iterativa tenemos el método de Newton-Raphson:\n\\[x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\\]\nNote que el método de Newton-Raphson es un método de segundo orden, es decir, el error en la aproximación \\(x_n\\) es proporcional al cuadrado del error en la aproximación \\(x_{n-1}\\).\nNote que el método de Newton-Raphson requiere el cálculo de la derivada de \\(f(x)\\), en algunos casos esto puede ser complicado, en estos casos se puede usar el método de la secante que es una aproximación numérica de la derivada.\nNote que el método de Newton-Raphson puede no converger, en estos casos se puede usar el método de la bisección.\nNote que el algoritmo necesita un punto inicial \\(x_0\\) cercano a la raíz que se quiere encontrar.\nEjercicio Escriba cuales son las ventajas y desventajas del método de Newton Raphson sobre el método de la bisección.\n\n## newton rapson method\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\ndef f(x):\n    return x**3-2*x-5\ndef df(x):\n    return 3*x**2-2\ndef newton(x0,eps):\n    x1=x0-f(x0)/df(x0)\n    while abs(x1-x0)>eps:\n        x0=x1\n        x1=x0-f(x0)/df(x0)\n    return x1\n\nEjercicio Note que el algoritmo anterior tiene un problema. ¿Cuál es? ¿Cómo lo solucionaría?\nReescriba el algoritmo anterior para que no tenga el problema que identificó.\nNote que en este método tenemos que calcular la derivada, lo podemos hacer de dos formas:\n\nEscribir deiractamente la derivada de la función.\nUtilizar la función Derivative de SymPy y luego evaluarla en el punto.\n\nEn el siguiente código usted vera como se puede usar la función Derivative de SymPy para calcular la derivada de una función y luego evaluarla en un punto.\n\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definir la variable simbólica\nx = sp.symbols('x')\n\n# Definir la función simbólica\nfuncion_simbolica = x**2 + 3*x + 2\n# Función numpy\nfuncion_numpy = sp.lambdify(x, funcion_simbolica, 'numpy')\n\n# Calcular la derivada\nderivada_simbolica = sp.diff(funcion_simbolica, x)\n\n# Convertir la derivada en una función de NumPy\nderivada_numpy = sp.lambdify(x, derivada_simbolica, 'numpy')\n\n# Crear un rango de valores para x\nx_vals = np.linspace(-10, 10, 400)\n\n# Calcular los valores correspondientes para la función y su derivada\nfuncion_vals = funcion_numpy(x_vals)\nderivada_vals = derivada_numpy(x_vals)\n\n\n\n# Crear una figura y ejes\nplt.figure(figsize=(10, 6))\nplt.title('Función y su Derivada')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Graficar la función original\nplt.plot(x_vals, funcion_vals, label='Función Original')\n\n# Graficar la derivada\nplt.plot(x_vals, derivada_vals, label='Derivada')\n\n# Mostrar leyenda\nplt.legend()\n\n# Mostrar el gráfico\nplt.grid()\nplt.show()\n\n\n\n\nEjercicio Use el anterior código para reformar el método de Newton-Raphson para que solo se necesite la función \\(f\\) y el internamente se calcule la derivada simbólica.\n\n\nlibrerías externas\nExisten diferentes librerías para calcular encontrar la raíz de una función, en este caso se usará la librería de scipy, la cual contiene una función llamada newton que permite encontrar la raíz de una función, para esto se debe ingresar la función, la derivada de la función y el valor inicial de la raíz. en el siguiente enlace encontraras las funciones que contiene la librería de scipy.\nEjercicio + Lea atentamente la documentación y haga un resumen de lo encontrado. + Encuentre la raíz de la función \\(f(x)=x^3-2x^2-5\\), usando los métodos de bisección y newton (su implementación, y el de la librería scipy ), compare los resultados obtenidos, aproximación, tiempo de computo, número de iteraciones, etc.\nPara elvaluar el tiempo de computo usted puede usar el siguiente código:\n```python\nimport time\n# Registro del tiempo de inicio\nstart_time = time.time()\n\n# Código de tu algoritmo\n# ...\n\n# Registro del tiempo de finalización\nend_time = time.time()\n\n# Cálculo del tiempo de ejecución\nexecution_time = end_time - start_time\n\nprint(\"Tiempo de ejecución:\", execution_time, \"segundos\")\n```"
  }
]